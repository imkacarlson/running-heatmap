<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Run Heatmap Mobile</title>
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/pmtiles@3.2.0/dist/pmtiles.js"></script>
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html, #map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    /* Mobile-optimized progress indicators */
    #progress-container {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      display: none;
      z-index: 1000;
    }

    .progress {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #aaa;
      border-radius: 3px;
      margin-top: 4px;
      position: relative;
    }

    .progress-bar {
      background: #007bff;
      width: 0%;
      height: 100%;
      border-radius: 2px;
      transition: width 0.2s ease;
    }

    /* Mobile loading indicator */
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 30px;
      border-radius: 8px;
      font-size: 16px;
      display: none;
      z-index: 1000;
    }

    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #007bff;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Mobile-optimized map controls */
    .map-controls {
      position: absolute;
      top: env(safe-area-inset-top, 20px);
      top: max(60px, env(safe-area-inset-top, 20px));
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-btn {
      background: white;
      border: 2px solid #ccc;
      border-radius: 8px;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      transition: all 0.2s;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .control-btn:active {
      transform: scale(0.95);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .control-btn.active {
      background: #007bff;
      color: white;
      border-color: #0056b3;
    }

    /* Mobile sidebar */
    #side-panel {
      position: absolute;
      top: env(safe-area-inset-top, 0px);
      right: -100vw;
      width: 85vw;
      max-width: 400px;
      height: calc(100vh - env(safe-area-inset-top, 0px));
      background: white;
      box-shadow: -4px 0 20px rgba(0,0,0,0.15);
      transition: right 0.3s ease;
      z-index: 1000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #side-panel.open {
      right: 0;
    }

    #side-panel.open.collapsed {
      width: 60px;
    }

    #side-panel.collapsed .panel-header,
    #side-panel.collapsed .panel-controls,
    #side-panel.collapsed .panel-content,
    #side-panel.collapsed .panel-summary {
      display: none;
    }

    /* Mobile expand button for collapsed state */
    .expand-btn {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      font-size: 20px;
      color: #666;
      background: white;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      width: 44px;
      height: 44px;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      user-select: none;
    }

    #side-panel.collapsed .expand-btn {
      display: flex;
    }

    #side-panel:not(.collapsed) .expand-btn {
      display: none;
    }

    .expand-btn:active {
      background: #f8f9fa;
      transform: translate(-50%, -50%) scale(0.95);
    }

    .panel-header {
      padding: 20px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      font-weight: bold;
      font-size: 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-close, .panel-collapse {
      cursor: pointer;
      font-size: 24px;
      color: #666;
      width: 32px;
      height: 32px;
      margin-left: 12px;
      touch-action: manipulation;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      -webkit-tap-highlight-color: transparent;
    }

    .panel-close:active, .panel-collapse:active {
      background: #e0e0e0;
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      -webkit-overflow-scrolling: touch;
    }

    .run-card {
      border: 2px solid #dee2e6;
      border-radius: 8px;
      margin-bottom: 12px;
      padding: 15px;
      background: white;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
    }

    .run-card:active {
      transform: scale(0.98);
    }

    .run-card.selected {
      background: #e3f2fd;
      border-color: #2196f3;
    }

    .run-date {
      font-weight: bold;
      margin-bottom: 8px;
      color: #333;
      font-size: 16px;
    }

    .run-stats {
      font-size: 14px;
      color: #666;
      display: flex;
      gap: 20px;
    }

    .run-checkbox {
      margin-right: 12px;
      transform: scale(1.2);
    }

    .panel-summary {
      padding: 15px 20px;
      background: #f8f9fa;
      border-top: 1px solid #dee2e6;
      font-size: 16px;
    }

    .panel-controls {
      padding: 15px 20px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      gap: 20px;
    }

    .control-link {
      color: #007bff;
      cursor: pointer;
      text-decoration: underline;
      font-size: 16px;
      padding: 8px;
      border-radius: 4px;
      -webkit-tap-highlight-color: transparent;
    }

    .control-link:active {
      background: #e3f2fd;
    }

    /* Mobile-specific overlay for drawing */
    #drawing-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 500;
      display: none;
      background: rgba(0,0,0,0.1);
    }

    #drawing-overlay.active {
      display: block;
    }

    /* Status message for mobile */
    #status-message {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
    }

    /* Touch-friendly clear button */
    #clear-selection-btn {
      background: #dc3545;
      color: white;
      border-color: #c82333;
    }

    /* Ensure text is readable on mobile */
    @media (max-width: 480px) {
      .panel-header {
        font-size: 16px;
        padding: 15px;
      }
      
      .run-card {
        padding: 12px;
      }
      
      .run-date {
        font-size: 15px;
      }
      
      .run-stats {
        font-size: 13px;
      }
    }
  </style>
</head>

<body>
  <div id="map"></div>
  
  <div class="map-controls">
    <div class="control-btn" id="zoom-in-btn" title="Zoom In">+</div>
    <div class="control-btn" id="zoom-out-btn" title="Zoom Out">−</div>
    <div class="control-btn" id="reset-north-btn" title="Reset North">N</div>
    <div class="control-btn" id="lasso-btn" title="Select Area">⊙</div>
    <div class="control-btn" id="clear-selection-btn" title="Clear Selection" style="display: none;">✕</div>
    <div class="control-btn" id="upload-btn" title="Upload GPX">⤴</div>
    <input type="file" id="file-input" accept=".gpx" multiple style="display:none;" />
  </div>
  
  <div id="drawing-overlay"></div>
  
  <div id="side-panel">
    <div class="expand-btn" id="expand-btn">◄</div>
    <div class="panel-header">
      <span>Selected Runs</span>
      <div>
        <span class="panel-collapse" id="panel-collapse">►</span>
        <span class="panel-close" id="panel-close">×</span>
      </div>
    </div>
    <div class="panel-controls">
      <span class="control-link" id="select-all">Select All</span>
      <span class="control-link" id="deselect-all">Deselect All</span>
    </div>
    <div class="panel-content" id="panel-content">
      <!-- Run cards will be populated here -->
    </div>
    <div class="panel-summary" id="panel-summary">
      <!-- Summary info will be shown here -->
    </div>
  </div>

  <div id="progress-container"></div>
  <div id="loading-indicator">
    <div class="spinner"></div>
    Loading map...
  </div>
  
  <div id="status-message"></div>

  <!-- Make the native HttpRangeServer plugin visible to JavaScript -->
  <script type="module">
    import { registerPlugin } from 'https://cdn.jsdelivr.net/npm/@capacitor/core@7/dist/index.js';
    // this creates the JS proxy and puts it where the rest of your code expects it
    window.HttpRangeServer = registerPlugin('HttpRangeServer');
  </script>
  
  <!-- Load spatial library -->
  <script src="main.js"></script>
  
  <script>
    // Initialize Capacitor plugin interface
    let initPromise = new Promise((resolve) => {
      const initCapacitor = () => {
        if (window.Capacitor && window.Capacitor.Plugins) {
          window.HttpRangeServer = window.Capacitor.Plugins.HttpRangeServer;
          console.log('[HEATMAP-HTTP] Capacitor HTTP Range Server plugin registered');
          resolve();
        } else if (window.Capacitor) {
          // Capacitor is available but plugins not yet ready, wait a bit
          setTimeout(() => {
            if (window.Capacitor.Plugins) {
              window.HttpRangeServer = window.Capacitor.Plugins.HttpRangeServer;
              console.log('[HEATMAP-HTTP] Capacitor HTTP Range Server plugin registered (delayed)');
              resolve();
            } else {
              console.warn('[HEATMAP-HTTP] Capacitor plugins not available, HTTP Range Server plugin not registered');
              resolve();
            }
          }, 100);
        } else {
          console.warn('[HEATMAP-HTTP] Capacitor not available, HTTP Range Server plugin not registered');
          resolve();
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCapacitor);
      } else {
        initCapacitor();
      }
    });

    // Mobile-optimized heatmap application
    
    let map;
    let selectedRuns = new Set();
    let sidebarOpen = false;
    let isDrawingMode = false;
    let isDrawing = false;
    let polygonCoords = [];
    let currentPolygon = null;
    let debounceTimeout = null;
    let lastDrawTime = 0;
    let drawThrottleMs = 16; // ~60fps

    // Initialize map
    async function initMap() {
      // Wait for Capacitor to be ready
      await initPromise;
      
      const protocol = new pmtiles.Protocol();
      maplibregl.addProtocol("pmtiles", protocol.tile.bind(protocol));

      map = new maplibregl.Map({
        container: 'map',
        style: {
          version: 8,
          sources: {},
          layers: []
        },
        center: [-98, 39],
        zoom: 4,
        touchZoomRotate: true,
        touchPitch: false
      });

      // Log any maplibre errors for debugging
      map.on('error', (e) => {
        console.error('Map error event:', e && e.error ? e.error : e);
        console.log('Map error details:', e);
      });

      // Aggressive tile prefetching for seamless zoom transitions
      map.prefetchZoomDelta = 4;

      map.on('load', async () => {
        const loader = document.getElementById('loading-indicator');
        loader.style.display = 'block';
        // Add OSM tiles
        map.addSource('osm-tiles', {
          type: 'raster',
          tiles: [
            'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
          ],
          tileSize: 256,
          attribution: '© OpenStreetMap contributors',
        });
        
        map.addLayer({ id: 'osm-layer', type: 'raster', source: 'osm-tiles' });

        // Load PMTiles using HTTP range server for better performance
        try {
          console.log('[HEATMAP-HTTP] Starting HTTP Range Server PMTiles load process...');
          
          // Start the HTTP range server
          let serverUrl = 'http://localhost:8080';
          let serverStarted = false;
          
          // Debug Capacitor state
          console.log('[HEATMAP-HTTP] Debugging Capacitor state:');
          console.log('[HEATMAP-HTTP] window.Capacitor exists:', !!window.Capacitor);
          console.log('[HEATMAP-HTTP] window.Capacitor.Plugins exists:', !!(window.Capacitor && window.Capacitor.Plugins));
          console.log('[HEATMAP-HTTP] Available plugins:', window.Capacitor && window.Capacitor.Plugins ? Object.keys(window.Capacitor.Plugins) : 'none');
          console.log('[HEATMAP-HTTP] window.HttpRangeServer exists:', !!window.HttpRangeServer);
          
          // Try multiple ways to access the plugin
          let httpRangeServer = null;
          
          if (window.Capacitor && window.Capacitor.Plugins) {
            // Try direct access
            httpRangeServer = window.Capacitor.Plugins.HttpRangeServerPlugin;
            console.log('[HEATMAP-HTTP] Direct access to HttpRangeServerPlugin:', !!httpRangeServer);
            
            // Try case variations
            if (!httpRangeServer) {
              httpRangeServer = window.Capacitor.Plugins.httpRangeServerPlugin;
              console.log('[HEATMAP-HTTP] Lowercase access to httpRangeServerPlugin:', !!httpRangeServer);
            }
            
            if (!httpRangeServer) {
              httpRangeServer = window.Capacitor.Plugins.HttpRangeServer;
              console.log('[HEATMAP-HTTP] Legacy HttpRangeServer access:', !!httpRangeServer);
            }
            
            // Try accessing by iterating through plugins
            if (!httpRangeServer) {
              const pluginKeys = Object.keys(window.Capacitor.Plugins);
              console.log('[HEATMAP-HTTP] All plugin keys:', pluginKeys);
              for (const key of pluginKeys) {
                console.log(`[HEATMAP-HTTP] Checking plugin: ${key}`);
                if (key.toLowerCase().includes('range')) {
                  console.log(`[HEATMAP-HTTP] Found potential plugin: ${key}`);
                  httpRangeServer = window.Capacitor.Plugins[key];
                  break;
                }
              }
            }
          }
          
          if (httpRangeServer) {
            window.HttpRangeServer = httpRangeServer;
            console.log('[HEATMAP-HTTP] Successfully found and assigned HttpRangeServer plugin');
            console.log('[HEATMAP-HTTP] Plugin methods:', Object.getOwnPropertyNames(httpRangeServer));
            console.log('[HEATMAP-HTTP] Has startServer method:', typeof httpRangeServer.startServer === 'function');
          } else {
            // The plugin isn't available - let's see if we can access it directly via Capacitor
            console.log('[HEATMAP-HTTP] Plugin not found. Trying direct Capacitor call...');
            try {
              const result = await window.Capacitor.Plugins.HttpRangeServer?.startServer?.();
              console.log('[HEATMAP-HTTP] Direct call result:', result);
            } catch (directError) {
              console.log('[HEATMAP-HTTP] Direct call failed:', directError);
            }
          }

          if (window.HttpRangeServer) {
            try {
              console.log('[HEATMAP-HTTP] Starting HTTP Range Server...');
              const serverResult = await window.HttpRangeServer.startServer();
              console.log('[HEATMAP-HTTP] Server start result:', serverResult);
              
              if (serverResult.success) {
                serverUrl = `http://localhost:${serverResult.port}`;
                serverStarted = true;
                console.log(`[HEATMAP-HTTP] HTTP Range Server started successfully at: ${serverUrl}`);
                
                // Wait a moment for server to be fully ready
                await new Promise(resolve => setTimeout(resolve, 500));
              } else {
                console.error('[HEATMAP-HTTP] Failed to start HTTP Range Server:', serverResult);
                throw new Error('Server failed to start: ' + JSON.stringify(serverResult));
              }
            } catch (serverError) {
              console.error('[HEATMAP-HTTP] HTTP Range Server plugin error:', serverError);
              throw serverError;
            }
          } else {
            console.error('[HEATMAP-HTTP] HttpRangeServer plugin not available - cannot proceed without range server');
            throw new Error('HttpRangeServer plugin not available');
          }
          
          if (!serverStarted) {
            throw new Error('Range server failed to start');
          }

          // Configure PMTiles to use HTTP range requests
          const pmtilesUrl = `${serverUrl}/data/runs.pmtiles`;
          console.log(`[HEATMAP-HTTP] Using PMTiles URL: ${pmtilesUrl}`);

          // Test if the PMTiles file is accessible
          try {
            const testResponse = await fetch(pmtilesUrl, { 
              method: 'HEAD',
              headers: { 'Range': 'bytes=0-0' }
            });
            console.log(`[HEATMAP-HTTP] PMTiles file test response: ${testResponse.status}`);
          } catch (testError) {
            console.warn('[HEATMAP-HTTP] PMTiles file test failed:', testError);
          }

          // Create PMTiles source from HTTP URL
          const pmtilesSource = new pmtiles.PMTiles(pmtilesUrl);
          console.log('[HEATMAP-HTTP] Created PMTiles instance from URL.');

          // Register with protocol
          protocol.add(pmtilesSource);
          console.log('[HEATMAP-HTTP] Successfully registered PMTiles instance.');

          // Add the map source using the pmtiles protocol
          const mapSourceUrl = `pmtiles://${pmtilesUrl}`;
          console.log(`[HEATMAP-HTTP] Adding map source with URL: ${mapSourceUrl}`);
          map.addSource('runsVec', {
            type: 'vector',
            url: mapSourceUrl,
            buffer: 128,
            maxzoom: 16,
            minzoom: 5
          });

          console.log('[HEATMAP-HTTP] Adding runsVec layer to map...');
          map.addLayer({
            id: 'runsVec',
            source: 'runsVec',
            'source-layer': 'runs',
            type: 'line',
            paint: {
              'line-color': 'rgba(255,0,0,0.5)',
              'line-width': ['interpolate', ['linear'], ['zoom'], 0, 1, 14, 3]
            },
            maxzoom: 24
          });

          console.log('[HEATMAP-HTTP] Successfully added map source and layer.');

        } catch (error) {
          console.error('[HEATMAP-HTTP] A critical error occurred during the HTTP Range PMTiles load:', error);
          console.error('[HEATMAP-HTTP] Error stack:', error.stack);
          if (window.showStatusForDebug) {
            window.showStatusForDebug(`Fatal error loading map tiles: ${error.message}`, 6000);
          }
        }

        try {
          await window.spatialIndex.loadData();
          // Local runs are now uploaded to the server; nothing to load locally
          showStatus('Interactive data loaded');
          updateMapDisplay();
        } finally {
          loader.style.display = 'none';
        }
      });

    }

    // Show status message
    function showStatus(message, duration = 3000) {
      const statusEl = document.getElementById('status-message');
      statusEl.textContent = message;
      statusEl.style.display = 'block';
      
      setTimeout(() => {
        statusEl.style.display = 'none';
      }, duration);
    }

    // Make showStatus available globally for debugging
    window.showStatusForDebug = showStatus;

    // Touch-optimized drawing functions
    function setupDrawing() {
      const overlay = document.getElementById('drawing-overlay');
      
      // Touch events for drawing (primary for mobile)
      overlay.addEventListener('touchstart', startDrawing, { passive: false, capture: true });
      overlay.addEventListener('touchmove', continueDrawing, { passive: false, capture: true });
      overlay.addEventListener('touchend', finishDrawing, { passive: false, capture: true });
      overlay.addEventListener('touchcancel', finishDrawing, { passive: false, capture: true });
      
      // Mouse events for desktop testing
      overlay.addEventListener('mousedown', startDrawing, { capture: true });
      overlay.addEventListener('mousemove', continueDrawing, { capture: true });
      overlay.addEventListener('mouseup', finishDrawing, { capture: true });
      
      // Prevent context menu on long touch
      overlay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        return false;
      });
    }

    function startDrawing(e) {
      if (!isDrawingMode) return;
      
      e.preventDefault();
      e.stopPropagation();
      isDrawing = true;
      lastDrawTime = Date.now();
      
      const point = getEventPoint(e);
      const lngLat = map.unproject(point);
      
      polygonCoords = [[lngLat.lng, lngLat.lat]];
      
      if (currentPolygon) {
        clearPolygonDisplay();
      }
      
      // Provide immediate visual feedback
      showStatus('Drawing selection area...', 1000);
    }

    function continueDrawing(e) {
      if (!isDrawing || !isDrawingMode) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // Throttle drawing to improve performance and reduce coordinate density
      const now = Date.now();
      if (now - lastDrawTime < drawThrottleMs) {
        return;
      }
      lastDrawTime = now;
      
      const point = getEventPoint(e);
      const lngLat = map.unproject(point);
      
      // Only add point if it's sufficiently different from the last point
      // Scale minimum distance based on zoom level
      const currentZoom = map.getZoom();
      const minDistance = getMinimumDrawDistance(currentZoom);
      
      if (polygonCoords.length > 0) {
        const lastCoord = polygonCoords[polygonCoords.length - 1];
        const distance = Math.sqrt(
          Math.pow(lngLat.lng - lastCoord[0], 2) + 
          Math.pow(lngLat.lat - lastCoord[1], 2)
        );
        
        if (distance < minDistance) {
          return;
        }
      }
      
      polygonCoords.push([lngLat.lng, lngLat.lat]);
      updatePolygonDisplay();
    }

    function finishDrawing(e) {
      if (!isDrawing || !isDrawingMode) return;
      
      e.preventDefault();
      e.stopPropagation();
      isDrawing = false;
      
      if (polygonCoords.length >= 3) {
        // Validate polygon area before proceeding
        const area = calculatePolygonArea(polygonCoords);
        const currentZoom = map.getZoom();
        const minArea = getMinimumPolygonArea(currentZoom);
        
        if (area < minArea) {
          showStatus('Selection area too small. Try drawing a larger area or zooming out.', 4000);
          clearPolygonDisplay();
          exitDrawingMode();
          return;
        }
        
        polygonCoords.push(polygonCoords[0]); // Close polygon
        updatePolygonDisplay();
        queryRunsInArea(polygonCoords);
        document.getElementById('clear-selection-btn').style.display = 'block';
        showStatus('Searching for runs in selected area...', 2000);
      } else {
        showStatus('Draw a larger area to select runs', 2000);
      }
      
      exitDrawingMode();
    }

    function getEventPoint(e) {
      if (e.touches && e.touches.length > 0) {
        return [e.touches[0].clientX, e.touches[0].clientY];
      }
      return [e.clientX, e.clientY];
    }

    function getMinimumDrawDistance(zoom) {
      // Scale minimum distance based on zoom level
      // Higher zoom = smaller minimum distance needed
      // Lower zoom = larger minimum distance needed
      if (zoom >= 16) return 0.00001; // Very high zoom
      if (zoom >= 14) return 0.00005; // High zoom
      if (zoom >= 12) return 0.0001;  // Medium zoom
      if (zoom >= 10) return 0.0005;  // Low zoom
      return 0.001; // Very low zoom
    }

    function getMinimumPolygonArea(zoom) {
      // Scale minimum area based on zoom level
      // Higher zoom = smaller minimum area allowed
      // Lower zoom = larger minimum area required
      if (zoom >= 16) return 0.000000001; // Very high zoom
      if (zoom >= 14) return 0.000000005; // High zoom
      if (zoom >= 12) return 0.00000001;  // Medium zoom
      if (zoom >= 10) return 0.00000005;  // Low zoom
      return 0.0000001; // Very low zoom
    }

    function calculatePolygonArea(coords) {
      // Calculate area using shoelace formula
      if (coords.length < 3) return 0;
      
      let area = 0;
      for (let i = 0; i < coords.length; i++) {
        const j = (i + 1) % coords.length;
        area += coords[i][0] * coords[j][1];
        area -= coords[j][0] * coords[i][1];
      }
      return Math.abs(area) / 2;
    }

    function updatePolygonDisplay() {
      clearPolygonDisplay();
      
      if (polygonCoords.length < 2) return;
      
      const geometry = isDrawing ? 
        { type: 'LineString', coordinates: polygonCoords } :
        { type: 'Polygon', coordinates: [polygonCoords] };
      
      map.addSource('selection-polygon', {
        type: 'geojson',
        data: { type: 'Feature', geometry: geometry }
      });
      
      if (isDrawing) {
        map.addLayer({
          id: 'selection-polygon-outline',
          type: 'line',
          source: 'selection-polygon',
          paint: {
            'line-color': '#007bff',
            'line-width': 3,
            'line-opacity': 0.8
          }
        });
      } else {
        map.addLayer({
          id: 'selection-polygon',
          type: 'fill',
          source: 'selection-polygon',
          paint: {
            'fill-color': '#007bff',
            'fill-opacity': 0.2
          }
        });
        
        map.addLayer({
          id: 'selection-polygon-outline',
          type: 'line',
          source: 'selection-polygon',
          paint: {
            'line-color': '#007bff',
            'line-width': 2,
            'line-dasharray': [5, 5]
          }
        });
      }
      
      if (!isDrawing) {
        currentPolygon = geometry;
      }
    }

    function clearPolygonDisplay() {
      if (map.getSource('selection-polygon')) {
        if (map.getLayer('selection-polygon-outline')) {
          map.removeLayer('selection-polygon-outline');
        }
        if (map.getLayer('selection-polygon')) {
          map.removeLayer('selection-polygon');
        }
        map.removeSource('selection-polygon');
      }
    }

    async function queryRunsInArea(coordinates) {
      try {
        const runs = await window.spatialIndex.queryPMTilesInPolygon(coordinates);
        displayRunsInPanel(runs);
        document.getElementById('side-panel').classList.add('open');
        sidebarOpen = true;
      } catch (error) {
        console.error('Error querying runs:', error);
        showStatus('Error finding runs in area');
      }
    }

    function displayRunsInPanel(runs) {
      const panelContent = document.getElementById('panel-content');
      const panelSummary = document.getElementById('panel-summary');
      
      panelContent.innerHTML = '';
      
      if (runs.length === 0) {
        panelContent.innerHTML = '<p style="text-align: center; color: #666; margin: 20px; font-size: 16px;">No runs found in selected area</p>';
        panelSummary.innerHTML = '';
        return;
      }

      // Sort runs by date
      runs.sort((a, b) => new Date(b.metadata.start_time) - new Date(a.metadata.start_time));

      // Create run cards
      runs.forEach(run => {
        const card = document.createElement('div');
        card.className = 'run-card selected';
        card.dataset.runId = run.id;
        
        const startDate = new Date(run.metadata.start_time);
        const distance = (run.metadata.distance * 0.000621371).toFixed(2);
        const duration = formatDuration(run.metadata.duration);
        const type = run.metadata.activity_type || 'other';
        let icon = '❓';
        if (type === 'run') icon = '🏃';
        else if (type === 'bike' || type === 'biking') icon = '🚴';
        else if (type === 'walk') icon = '🚶';
        else if (type === 'hike') icon = '🥾';
        
        card.innerHTML = `
          <div style="display: flex; align-items: center;">
            <input type="checkbox" class="run-checkbox" checked>
            <div style="flex: 1;">
              <div class="run-date">${startDate.toLocaleDateString()} ${startDate.toLocaleTimeString()}</div>
              <div class="run-stats">
                <span>📏 ${distance} mi</span>
                <span>⏱️ ${duration}</span>
              </div>
            </div>
            <div style="font-size:20px;margin-left:4px;">${icon}</div>
          </div>
        `;

        selectedRuns.add(run.id);
        
        const checkbox = card.querySelector('.run-checkbox');
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedRuns.add(run.id);
            card.classList.add('selected');
          } else {
            selectedRuns.delete(run.id);
            card.classList.remove('selected');
          }
          updateMapDisplay();
        });

        panelContent.appendChild(card);
      });

      // Update summary
      const mostRecentRun = runs[0];
      const mostRecentDate = new Date(mostRecentRun.metadata.start_time);
      panelSummary.innerHTML = `
        <strong>${runs.length}</strong> runs found<br>
        <strong>Last run:</strong> ${mostRecentDate.toLocaleDateString()}
      `;

      updateMapDisplay();
    }

    function formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      } else {
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }
    }

      function updateMapDisplay() {
        if (!map.getLayer('runsVec')) return;

        let filter = null;
        if (sidebarOpen) {
          if (selectedRuns.size === 0) {
            filter = ['==', ['get', 'id'], -1];
          } else {
            const ids = Array.from(selectedRuns, id => Number(id));
            filter = ['in', ['get', 'id'], ['literal', ids]];
          }
        }

        map.setFilter('runsVec', filter);
      }

    function exitDrawingMode() {
      isDrawingMode = false;
      isDrawing = false;
      document.getElementById('lasso-btn').classList.remove('active');
      document.getElementById('drawing-overlay').classList.remove('active');
    }

    function clearSelection() {
      clearPolygonDisplay();
      currentPolygon = null;
      polygonCoords = [];
      document.getElementById('clear-selection-btn').style.display = 'none';
      document.getElementById('side-panel').classList.remove('open');
      sidebarOpen = false;
      selectedRuns.clear();
      updateMapDisplay();
    }

    function normalizeActivityType(raw) {
      if (!raw) return 'other';
      const t = raw.toLowerCase();
      if (t.includes('run') || t.includes('jog')) return 'run';
      if (t.includes('bike') || t.includes('ride') || t.includes('cycl')) return 'bike';
      if (t.includes('walk')) return 'walk';
      if (t.includes('hike')) return 'hike';
      return 'other';
    }

    function haversine(a, b) {
      const R = 6371000;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(b[1] - a[1]);
      const dLon = toRad(b[0] - a[0]);
      const lat1 = toRad(a[1]);
      const lat2 = toRad(b[1]);
      const s = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s));
    }

    function computeDistance(coords) {
      let d = 0;
      for (let i = 1; i < coords.length; i++) {
        d += haversine(coords[i - 1], coords[i]);
      }
      return d;
    }

    function simplifyCoords(coords, tolerance) {
      if (coords.length <= 2) return coords;
      const simplified = [coords[0]];
      let last = coords[0];
      for (let i = 1; i < coords.length - 1; i++) {
        const c = coords[i];
        const dx = c[0] - last[0];
        const dy = c[1] - last[1];
        if (Math.sqrt(dx * dx + dy * dy) > tolerance) {
          simplified.push(c);
          last = c;
        }
      }
      simplified.push(coords[coords.length - 1]);
      return simplified;
    }

    function parseGpxText(text) {
      const doc = new DOMParser().parseFromString(text, 'application/xml');
      const trkpts = Array.from(doc.getElementsByTagName('trkpt'));
      const coords = [];
      const times = [];
      trkpts.forEach(pt => {
        const lat = parseFloat(pt.getAttribute('lat'));
        const lon = parseFloat(pt.getAttribute('lon'));
        coords.push([lon, lat]);
        const timeEl = pt.getElementsByTagName('time')[0];
        if (timeEl) times.push(new Date(timeEl.textContent));
      });
      const typeEl = doc.querySelector('trk > type');
      const rawType = typeEl ? typeEl.textContent.trim() : null;
      const meta = {
        start_time: times.length ? times[0].toISOString() : null,
        end_time: times.length ? times[times.length - 1].toISOString() : null,
        duration: times.length ? (times[times.length - 1] - times[0]) / 1000 : 0,
        distance: computeDistance(coords),
        activity_type: normalizeActivityType(rawType),
        activity_raw: rawType
      };
      return { coords, metadata: meta };
    }

      async function handleFileUpload(files) {
        const list = Array.from(files || []);

        showStatus('Uploading and processing runs...', 10000);

        try {
          for (const file of list) {
            const text = await file.text();
            const { coords, metadata } = parseGpxText(text);
            metadata.source_file = file.name;

            await window.spatialIndex.addRun(coords, metadata);
          }

          showStatus(`Successfully added ${list.length} run(s) to map`);
          updateMapDisplay();

        } catch (error) {
          console.error('Upload failed:', error);
          showStatus('Upload failed: ' + error.message);
        }
      }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      setupDrawing();
      
      // Control buttons
      document.getElementById('zoom-in-btn').addEventListener('click', () => {
        map.zoomIn();
      });

      document.getElementById('zoom-out-btn').addEventListener('click', () => {
        map.zoomOut();
      });

      document.getElementById('reset-north-btn').addEventListener('click', () => {
        map.setBearing(0);
      });


      document.getElementById('lasso-btn').addEventListener('click', () => {
        if (!isDrawingMode) {
          isDrawingMode = true;
          document.getElementById('lasso-btn').classList.add('active');
          document.getElementById('drawing-overlay').classList.add('active');
          showStatus('Draw on map to select area');
        } else {
          exitDrawingMode();
        }
      });

      document.getElementById('clear-selection-btn').addEventListener('click', clearSelection);
      document.getElementById('panel-close').addEventListener('click', clearSelection);

      // Mobile panel collapse functionality
      document.getElementById('panel-collapse').addEventListener('click', () => {
        const panel = document.getElementById('side-panel');
        panel.classList.add('collapsed');
      });

      // Mobile panel expand functionality
      document.getElementById('expand-btn').addEventListener('click', () => {
        const panel = document.getElementById('side-panel');
        panel.classList.remove('collapsed');
      });

      // Panel controls
      document.getElementById('select-all').addEventListener('click', () => {
        const checkboxes = document.querySelectorAll('.run-checkbox');
        checkboxes.forEach(checkbox => {
          if (!checkbox.checked) {
            checkbox.checked = true;
            checkbox.dispatchEvent(new Event('change'));
          }
        });
      });

      document.getElementById('deselect-all').addEventListener('click', () => {
        const checkboxes = document.querySelectorAll('.run-checkbox');
        checkboxes.forEach(checkbox => {
          if (checkbox.checked) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change'));
          }
        });
      });

      document.getElementById('upload-btn').addEventListener('click', () => {
        document.getElementById('file-input').click();
      });

      document.getElementById('file-input').addEventListener('change', (e) => {
        handleFileUpload(e.target.files);
        e.target.value = '';
      });
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Run Heatmap Mobile</title>
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/pmtiles@3.2.0/dist/pmtiles.js"></script>
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html, #map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    /* Mobile-optimized progress indicators */
    #progress-container {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      display: none;
      z-index: 1000;
    }

    .progress {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #aaa;
      border-radius: 3px;
      margin-top: 4px;
      position: relative;
    }

    .progress-bar {
      background: #007bff;
      width: 0%;
      height: 100%;
      border-radius: 2px;
      transition: width 0.2s ease;
    }

    /* Mobile loading indicator */
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 30px;
      border-radius: 8px;
      font-size: 16px;
      display: none;
      z-index: 1000;
    }

    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #007bff;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Mobile-optimized map controls */
    .map-controls {
      position: absolute;
      top: env(safe-area-inset-top, 20px);
      top: max(60px, env(safe-area-inset-top, 20px));
      right: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-btn {
      background: white;
      border: 2px solid #ccc;
      border-radius: 8px;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      font-weight: bold;
      color: #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      transition: all 0.2s;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .control-btn:active {
      transform: scale(0.95);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .control-btn.active {
      background: #007bff;
      color: white;
      border-color: #0056b3;
    }

    /* Mobile sidebar */
    #side-panel {
      position: absolute;
      top: env(safe-area-inset-top, 0px);
      right: -100vw;
      width: 85vw;
      max-width: 400px;
      height: calc(100vh - env(safe-area-inset-top, 0px));
      background: white;
      box-shadow: -4px 0 20px rgba(0,0,0,0.15);
      transition: right 0.3s ease;
      z-index: 1000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #side-panel.open {
      right: 0;
    }

    #side-panel.open.collapsed {
      width: 60px;
    }

    #side-panel.collapsed .panel-header,
    #side-panel.collapsed .panel-controls,
    #side-panel.collapsed .panel-content,
    #side-panel.collapsed .panel-summary {
      display: none;
    }

    /* Mobile expand button for collapsed state */
    .expand-btn {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      cursor: pointer;
      font-size: 20px;
      color: #666;
      background: white;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      width: 44px;
      height: 44px;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      user-select: none;
    }

    #side-panel.collapsed .expand-btn {
      display: flex;
    }

    #side-panel:not(.collapsed) .expand-btn {
      display: none;
    }

    .expand-btn:active {
      background: #f8f9fa;
      transform: translate(-50%, -50%) scale(0.95);
    }

    .panel-header {
      padding: 20px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      font-weight: bold;
      font-size: 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-close, .panel-collapse {
      cursor: pointer;
      font-size: 24px;
      color: #666;
      width: 32px;
      height: 32px;
      margin-left: 12px;
      touch-action: manipulation;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      -webkit-tap-highlight-color: transparent;
    }

    .panel-close:active, .panel-collapse:active {
      background: #e0e0e0;
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      -webkit-overflow-scrolling: touch;
    }

    .run-card {
      border: 2px solid #dee2e6;
      border-radius: 8px;
      margin-bottom: 12px;
      padding: 15px;
      background: white;
      cursor: pointer;
      transition: all 0.2s;
      -webkit-tap-highlight-color: transparent;
    }

    .run-card:active {
      transform: scale(0.98);
    }

    .run-card.selected {
      background: #e3f2fd;
      border-color: #2196f3;
    }

    .run-date {
      font-weight: bold;
      margin-bottom: 8px;
      color: #333;
      font-size: 16px;
    }

    .run-stats {
      font-size: 14px;
      color: #666;
      display: flex;
      gap: 20px;
    }

    .run-checkbox {
      margin-right: 12px;
      transform: scale(1.2);
    }

    .panel-summary {
      padding: 15px 20px;
      background: #f8f9fa;
      border-top: 1px solid #dee2e6;
      font-size: 16px;
    }

    .panel-controls {
      padding: 15px 20px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      gap: 20px;
    }

    .control-link {
      color: #007bff;
      cursor: pointer;
      text-decoration: underline;
      font-size: 16px;
      padding: 8px;
      border-radius: 4px;
      -webkit-tap-highlight-color: transparent;
    }

    .control-link:active {
      background: #e3f2fd;
    }

    /* Extras panel */
    #extras-panel {
      position: absolute;
      top: env(safe-area-inset-top, 0px);
      left: -100vw;
      width: 85vw;
      max-width: 360px;
      height: calc(100vh - env(safe-area-inset-top, 0px));
      background: white;
      box-shadow: 2px 0 10px rgba(0,0,0,0.15);
      transition: left 0.3s ease;
      z-index: 1000;
      overflow-y: auto;
    }

    #extras-panel.open {
      left: 0;
    }

    #extras-panel.open.collapsed {
      width: 60px;
    }

    #extras-panel.collapsed .extras-header,
    #extras-panel.collapsed .panel-content {
      display: none;
    }

    #extras-panel.collapsed .extras-expand-btn {
      display: flex;
    }

    #extras-panel:not(.collapsed) .extras-expand-btn {
      display: none;
    }

    /* Mobile expand button for collapsed extras panel */
    .extras-expand-btn {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #007bff;
      color: white;
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      z-index: 1001;
    }

    .extras-header {
      padding: 18px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Mobile-specific overlay for drawing */
    #drawing-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 500;
      display: none;
      background: rgba(0,0,0,0.1);
    }

    #drawing-overlay.active {
      display: block;
    }

    /* Status message for mobile */
    #status-message {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 20px;
      border-radius: 6px;
      font-size: 14px;
      display: none;
      z-index: 1000;
    }

    /* Touch-friendly clear button */
    #clear-selection-btn {
      background: #dc3545;
      color: white;
      border-color: #c82333;
    }

    /* Ensure text is readable on mobile */
    @media (max-width: 480px) {
      .panel-header {
        font-size: 16px;
        padding: 15px;
      }
      
      .run-card {
        padding: 12px;
      }
      
      .run-date {
        font-size: 15px;
      }
      
      .run-stats {
        font-size: 13px;
      }
    }
  </style>
</head>

<body>
  <div id="map"></div>
  
  <div class="map-controls">
    <div class="control-btn" id="zoom-in-btn" title="Zoom In">+</div>
    <div class="control-btn" id="zoom-out-btn" title="Zoom Out">−</div>
    <div class="control-btn" id="reset-north-btn" title="Reset North">N</div>
    <div class="control-btn" id="lasso-btn" title="Select Area">⊙</div>
    <div class="control-btn" id="clear-selection-btn" title="Clear Selection" style="display: none;">✕</div>
    <div class="control-btn" id="upload-btn" title="Upload GPX">⤴</div>
    <div class="control-btn" id="extras-btn" title="More">⋯</div>
    <input type="file" id="file-input" accept=".gpx" multiple style="display:none;" />
  </div>
  
  <div id="drawing-overlay"></div>
  
  <div id="side-panel">
    <div class="expand-btn" id="expand-btn">◄</div>
    <div class="panel-header">
      <span>Selected Runs</span>
      <div>
        <span class="panel-collapse" id="panel-collapse">►</span>
        <span class="panel-close" id="panel-close">×</span>
      </div>
    </div>
    <div class="panel-controls">
      <span class="control-link" id="select-all">Select All</span>
      <span class="control-link" id="deselect-all">Deselect All</span>
    </div>
    <div class="panel-content" id="panel-content">
      <!-- Run cards will be populated here -->
    </div>
    <div class="panel-summary" id="panel-summary">
      <!-- Summary info will be shown here -->
    </div>
  </div>

  <div id="extras-panel">
    <div class="extras-expand-btn" id="extras-expand-btn">◄</div>
    <div class="extras-header">
      <span>Extra Features</span>
      <div>
        <span class="panel-collapse" id="extras-collapse">►</span>
        <span id="extras-close" style="cursor:pointer">×</span>
      </div>
    </div>
    <div id="extras-content" class="panel-content"></div>
  </div>

  <div id="progress-container"></div>
  <div id="loading-indicator">
    <div class="spinner"></div>
    Loading map...
  </div>
  
  <div id="status-message"></div>

  <!-- Make the native HttpRangeServer plugin visible to JavaScript -->
  <script type="module">
    import { registerPlugin } from 'https://cdn.jsdelivr.net/npm/@capacitor/core@7/dist/index.js';
    // this creates the JS proxy and puts it where the rest of your code expects it
    window.HttpRangeServer = registerPlugin('HttpRangeServer');
  </script>
  
  <!-- Load spatial library -->
  <script src="main.js"></script>
  
  <script>
    // Initialize Capacitor plugin interface
    let initPromise = new Promise((resolve) => {
      const initCapacitor = () => {
        if (window.Capacitor && window.Capacitor.Plugins) {
          window.HttpRangeServer = window.Capacitor.Plugins.HttpRangeServer;
          console.log('[HEATMAP-HTTP] Capacitor HTTP Range Server plugin registered');
          resolve();
        } else if (window.Capacitor) {
          // Capacitor is available but plugins not yet ready, wait a bit
          setTimeout(() => {
            if (window.Capacitor.Plugins) {
              window.HttpRangeServer = window.Capacitor.Plugins.HttpRangeServer;
              console.log('[HEATMAP-HTTP] Capacitor HTTP Range Server plugin registered (delayed)');
              resolve();
            } else {
              console.warn('[HEATMAP-HTTP] Capacitor plugins not available, HTTP Range Server plugin not registered');
              resolve();
            }
          }, 100);
        } else {
          console.warn('[HEATMAP-HTTP] Capacitor not available, HTTP Range Server plugin not registered');
          resolve();
        }
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCapacitor);
      } else {
        initCapacitor();
      }
    });

    // Mobile-optimized heatmap application
    
    let map;
    let selectedRuns = new Set();
    let sidebarOpen = false;
    let isDrawingMode = false;
    let isDrawing = false;
    let polygonCoords = [];
    let currentPolygon = null;
    let debounceTimeout = null;
    let lastDrawTime = 0;
    let drawThrottleMs = 16; // ~60fps

    // Initialize map
    async function initMap() {
      // Wait for Capacitor to be ready
      await initPromise;
      
      const protocol = new pmtiles.Protocol();
      maplibregl.addProtocol("pmtiles", protocol.tile.bind(protocol));

      map = new maplibregl.Map({
        container: 'map',
        style: {
          version: 8,
          sources: {},
          layers: []
        },
        center: [-98, 39],
        zoom: 4,
        maxZoom: 16,
        touchZoomRotate: true,
        touchPitch: false
      });

      // Log any maplibre errors for debugging
      map.on('error', (e) => {
        console.error('Map error event:', e && e.error ? e.error : e);
        console.log('Map error details:', e);
      });

      // Optimize prefetching for better zoom performance
      map.prefetchZoomDelta = 2;
      // Increase tile cache for better zoom-out performance
      if (map.setMaxTileCacheSize) {
        map.setMaxTileCacheSize(1024);
      }

      map.on('load', async () => {
        const loader = document.getElementById('loading-indicator');
        loader.style.display = 'block';
        // Add OSM tiles
        map.addSource('osm-tiles', {
          type: 'raster',
          tiles: [
            'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
          ],
          tileSize: 256,
          attribution: '© OpenStreetMap contributors',
        });
        
        map.addLayer({ id: 'osm-layer', type: 'raster', source: 'osm-tiles' });

        // Load PMTiles using HTTP range server for better performance
        try {
          console.log('[HEATMAP-HTTP] Starting HTTP Range Server PMTiles load process...');
          
          // Start the HTTP range server
          let serverUrl = 'http://localhost:8080';
          let serverStarted = false;
          
          // Debug Capacitor state
          console.log('[HEATMAP-HTTP] Debugging Capacitor state:');
          console.log('[HEATMAP-HTTP] window.Capacitor exists:', !!window.Capacitor);
          console.log('[HEATMAP-HTTP] window.Capacitor.Plugins exists:', !!(window.Capacitor && window.Capacitor.Plugins));
          console.log('[HEATMAP-HTTP] Available plugins:', window.Capacitor && window.Capacitor.Plugins ? Object.keys(window.Capacitor.Plugins) : 'none');
          console.log('[HEATMAP-HTTP] window.HttpRangeServer exists:', !!window.HttpRangeServer);
          
          // Try multiple ways to access the plugin
          let httpRangeServer = null;
          
          if (window.Capacitor && window.Capacitor.Plugins) {
            // Try direct access
            httpRangeServer = window.Capacitor.Plugins.HttpRangeServerPlugin;
            console.log('[HEATMAP-HTTP] Direct access to HttpRangeServerPlugin:', !!httpRangeServer);
            
            // Try case variations
            if (!httpRangeServer) {
              httpRangeServer = window.Capacitor.Plugins.httpRangeServerPlugin;
              console.log('[HEATMAP-HTTP] Lowercase access to httpRangeServerPlugin:', !!httpRangeServer);
            }
            
            if (!httpRangeServer) {
              httpRangeServer = window.Capacitor.Plugins.HttpRangeServer;
              console.log('[HEATMAP-HTTP] Legacy HttpRangeServer access:', !!httpRangeServer);
            }
            
            // Try accessing by iterating through plugins
            if (!httpRangeServer) {
              const pluginKeys = Object.keys(window.Capacitor.Plugins);
              console.log('[HEATMAP-HTTP] All plugin keys:', pluginKeys);
              for (const key of pluginKeys) {
                console.log(`[HEATMAP-HTTP] Checking plugin: ${key}`);
                if (key.toLowerCase().includes('range')) {
                  console.log(`[HEATMAP-HTTP] Found potential plugin: ${key}`);
                  httpRangeServer = window.Capacitor.Plugins[key];
                  break;
                }
              }
            }
          }
          
          if (httpRangeServer) {
            window.HttpRangeServer = httpRangeServer;
            console.log('[HEATMAP-HTTP] Successfully found and assigned HttpRangeServer plugin');
            console.log('[HEATMAP-HTTP] Plugin methods:', Object.getOwnPropertyNames(httpRangeServer));
            console.log('[HEATMAP-HTTP] Has startServer method:', typeof httpRangeServer.startServer === 'function');
          } else {
            // The plugin isn't available - let's see if we can access it directly via Capacitor
            console.log('[HEATMAP-HTTP] Plugin not found. Trying direct Capacitor call...');
            try {
              const result = await window.Capacitor.Plugins.HttpRangeServer?.startServer?.();
              console.log('[HEATMAP-HTTP] Direct call result:', result);
            } catch (directError) {
              console.log('[HEATMAP-HTTP] Direct call failed:', directError);
            }
          }

          if (window.HttpRangeServer) {
            try {
              console.log('[HEATMAP-HTTP] Starting HTTP Range Server...');
              const serverResult = await window.HttpRangeServer.startServer();
              console.log('[HEATMAP-HTTP] Server start result:', serverResult);
              
              if (serverResult.success) {
                serverUrl = `http://localhost:${serverResult.port}`;
                serverStarted = true;
                console.log(`[HEATMAP-HTTP] HTTP Range Server started successfully at: ${serverUrl}`);
                
                // Wait a moment for server to be fully ready
                await new Promise(resolve => setTimeout(resolve, 500));
              } else {
                console.error('[HEATMAP-HTTP] Failed to start HTTP Range Server:', serverResult);
                throw new Error('Server failed to start: ' + JSON.stringify(serverResult));
              }
            } catch (serverError) {
              console.error('[HEATMAP-HTTP] HTTP Range Server plugin error:', serverError);
              throw serverError;
            }
          } else {
            console.error('[HEATMAP-HTTP] HttpRangeServer plugin not available - cannot proceed without range server');
            throw new Error('HttpRangeServer plugin not available');
          }
          
          if (!serverStarted) {
            throw new Error('Range server failed to start');
          }

          // Configure PMTiles to use HTTP range requests
          const pmtilesUrl = `${serverUrl}/data/runs.pmtiles`;
          console.log(`[HEATMAP-HTTP] Using PMTiles URL: ${pmtilesUrl}`);

          // Test if the PMTiles file is accessible
          try {
            const testResponse = await fetch(pmtilesUrl, { 
              method: 'HEAD',
              headers: { 'Range': 'bytes=0-0' }
            });
            console.log(`[HEATMAP-HTTP] PMTiles file test response: ${testResponse.status}`);
            
            // Try a small range request to verify server is working
            const rangeTestResponse = await fetch(pmtilesUrl, { 
              method: 'GET',
              headers: { 'Range': 'bytes=0-1023' }
            });
            console.log(`[HEATMAP-HTTP] PMTiles range test response: ${rangeTestResponse.status}`);
          } catch (testError) {
            console.warn('[HEATMAP-HTTP] PMTiles file test failed:', testError);
          }

          // Create PMTiles source normally (server is working fine)
          console.log('[HEATMAP-HTTP] Creating PMTiles source.');
          
          const pmtilesSource = new pmtiles.PMTiles(pmtilesUrl);
          console.log('[HEATMAP-HTTP] Created PMTiles instance.');

          // Register with protocol
          protocol.add(pmtilesSource);
          console.log('[HEATMAP-HTTP] Successfully registered PMTiles instance.');

          // Add the map source using the pmtiles protocol
          const mapSourceUrl = `pmtiles://${pmtilesUrl}`;
          console.log(`[HEATMAP-HTTP] Adding map source with URL: ${mapSourceUrl}`);
          map.addSource('runsVec', {
            type: 'vector',
            url: mapSourceUrl,
            buffer: 64,
            maxzoom: 16,
            minzoom: 4
          });

          console.log('[HEATMAP-HTTP] Adding runsVec layer to map...');
          map.addLayer({
            id: 'runsVec',
            source: 'runsVec',
            'source-layer': 'runs',
            type: 'line',
            paint: {
              'line-color': 'rgba(255,0,0,0.5)',
              'line-width': ['interpolate', ['linear'], ['zoom'], 0, 1, 14, 3]
            },
            maxzoom: 16
          });

          console.log('[HEATMAP-HTTP] Successfully added map source and layer.');

        } catch (error) {
          console.error('[HEATMAP-HTTP] A critical error occurred during the HTTP Range PMTiles load:', error);
          console.error('[HEATMAP-HTTP] Error stack:', error.stack);
          if (window.showStatusForDebug) {
            window.showStatusForDebug(`Fatal error loading map tiles: ${error.message}`, 6000);
          }
        }

        try {
          await window.spatialIndex.loadData();
          // Local runs are now uploaded to the server; nothing to load locally
          showStatus('Interactive data loaded');
          updateMapDisplay();
        } finally {
          loader.style.display = 'none';
        }
      });

      // Update local runs overlay when map view changes
      map.on('moveend', () => {
        updateUnifiedRunsLayer();
      });

      map.on('zoomend', () => {
        updateUnifiedRunsLayer();
      });

    }

    // Show status message
    function showStatus(message, duration = 3000) {
      const statusEl = document.getElementById('status-message');
      statusEl.textContent = message;
      statusEl.style.display = 'block';
      
      setTimeout(() => {
        statusEl.style.display = 'none';
      }, duration);
    }

    // Make showStatus available globally for debugging
    window.showStatusForDebug = showStatus;

    // Touch-optimized drawing functions
    function setupDrawing() {
      const overlay = document.getElementById('drawing-overlay');
      
      // Touch events for drawing (primary for mobile)
      overlay.addEventListener('touchstart', startDrawing, { passive: false, capture: true });
      overlay.addEventListener('touchmove', continueDrawing, { passive: false, capture: true });
      overlay.addEventListener('touchend', finishDrawing, { passive: false, capture: true });
      overlay.addEventListener('touchcancel', finishDrawing, { passive: false, capture: true });
      
      // Mouse events for desktop testing
      overlay.addEventListener('mousedown', startDrawing, { capture: true });
      overlay.addEventListener('mousemove', continueDrawing, { capture: true });
      overlay.addEventListener('mouseup', finishDrawing, { capture: true });
      
      // Prevent context menu on long touch
      overlay.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        return false;
      });
    }

    function startDrawing(e) {
      if (!isDrawingMode) return;
      
      e.preventDefault();
      e.stopPropagation();
      isDrawing = true;
      lastDrawTime = Date.now();
      
      const point = getEventPoint(e);
      const lngLat = map.unproject(point);
      
      polygonCoords = [[lngLat.lng, lngLat.lat]];
      
      if (currentPolygon) {
        clearPolygonDisplay();
      }
      
      // Provide immediate visual feedback
      showStatus('Drawing selection area...', 1000);
    }

    function continueDrawing(e) {
      if (!isDrawing || !isDrawingMode) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // Throttle drawing to improve performance and reduce coordinate density
      const now = Date.now();
      if (now - lastDrawTime < drawThrottleMs) {
        return;
      }
      lastDrawTime = now;
      
      const point = getEventPoint(e);
      const lngLat = map.unproject(point);
      
      // Only add point if it's sufficiently different from the last point
      // Scale minimum distance based on zoom level
      const currentZoom = map.getZoom();
      const minDistance = getMinimumDrawDistance(currentZoom);
      
      if (polygonCoords.length > 0) {
        const lastCoord = polygonCoords[polygonCoords.length - 1];
        const distance = Math.sqrt(
          Math.pow(lngLat.lng - lastCoord[0], 2) + 
          Math.pow(lngLat.lat - lastCoord[1], 2)
        );
        
        if (distance < minDistance) {
          return;
        }
      }
      
      polygonCoords.push([lngLat.lng, lngLat.lat]);
      updatePolygonDisplay();
    }

    function finishDrawing(e) {
      if (!isDrawing || !isDrawingMode) return;
      
      e.preventDefault();
      e.stopPropagation();
      isDrawing = false;
      
      if (polygonCoords.length >= 3) {
        // Validate polygon area before proceeding
        const area = calculatePolygonArea(polygonCoords);
        const currentZoom = map.getZoom();
        const minArea = getMinimumPolygonArea(currentZoom);
        
        if (area < minArea) {
          showStatus('Selection area too small. Try drawing a larger area or zooming out.', 4000);
          clearPolygonDisplay();
          exitDrawingMode();
          return;
        }
        
        polygonCoords.push(polygonCoords[0]); // Close polygon
        updatePolygonDisplay();
        queryRunsInArea(polygonCoords);
        document.getElementById('clear-selection-btn').style.display = 'block';
        showStatus('Searching for runs in selected area...', 2000);
      } else {
        showStatus('Draw a larger area to select runs', 2000);
      }
      
      exitDrawingMode();
    }

    function getEventPoint(e) {
      if (e.touches && e.touches.length > 0) {
        return [e.touches[0].clientX, e.touches[0].clientY];
      }
      return [e.clientX, e.clientY];
    }

    function getMinimumDrawDistance(zoom) {
      // Scale minimum distance based on zoom level
      // Higher zoom = smaller minimum distance needed
      // Lower zoom = larger minimum distance needed
      if (zoom >= 16) return 0.00001; // Very high zoom
      if (zoom >= 14) return 0.00005; // High zoom
      if (zoom >= 12) return 0.0001;  // Medium zoom
      if (zoom >= 10) return 0.0005;  // Low zoom
      return 0.001; // Very low zoom
    }

    function getMinimumPolygonArea(zoom) {
      // Scale minimum area based on zoom level
      // Higher zoom = smaller minimum area allowed
      // Lower zoom = larger minimum area required
      if (zoom >= 16) return 0.000000001; // Very high zoom
      if (zoom >= 14) return 0.000000005; // High zoom
      if (zoom >= 12) return 0.00000001;  // Medium zoom
      if (zoom >= 10) return 0.00000005;  // Low zoom
      return 0.0000001; // Very low zoom
    }

    function calculatePolygonArea(coords) {
      // Calculate area using shoelace formula
      if (coords.length < 3) return 0;
      
      let area = 0;
      for (let i = 0; i < coords.length; i++) {
        const j = (i + 1) % coords.length;
        area += coords[i][0] * coords[j][1];
        area -= coords[j][0] * coords[i][1];
      }
      return Math.abs(area) / 2;
    }

    function updatePolygonDisplay() {
      clearPolygonDisplay();
      
      if (polygonCoords.length < 2) return;
      
      const geometry = isDrawing ? 
        { type: 'LineString', coordinates: polygonCoords } :
        { type: 'Polygon', coordinates: [polygonCoords] };
      
      map.addSource('selection-polygon', {
        type: 'geojson',
        data: { type: 'Feature', geometry: geometry }
      });
      
      if (isDrawing) {
        map.addLayer({
          id: 'selection-polygon-outline',
          type: 'line',
          source: 'selection-polygon',
          paint: {
            'line-color': '#007bff',
            'line-width': 3,
            'line-opacity': 0.8
          }
        });
      } else {
        map.addLayer({
          id: 'selection-polygon',
          type: 'fill',
          source: 'selection-polygon',
          paint: {
            'fill-color': '#007bff',
            'fill-opacity': 0.2
          }
        });
        
        map.addLayer({
          id: 'selection-polygon-outline',
          type: 'line',
          source: 'selection-polygon',
          paint: {
            'line-color': '#007bff',
            'line-width': 2,
            'line-dasharray': [5, 5]
          }
        });
      }
      
      if (!isDrawing) {
        currentPolygon = geometry;
      }
    }

    function clearPolygonDisplay() {
      if (map.getSource('selection-polygon')) {
        if (map.getLayer('selection-polygon-outline')) {
          map.removeLayer('selection-polygon-outline');
        }
        if (map.getLayer('selection-polygon')) {
          map.removeLayer('selection-polygon');
        }
        map.removeSource('selection-polygon');
      }
    }

    async function queryRunsInArea(coordinates) {
      try {
        const runs = await queryUnifiedRunsInPolygon(coordinates);
        displayRunsInPanel(runs);
        document.getElementById('side-panel').classList.add('open');
        sidebarOpen = true;
      } catch (error) {
        console.error('Error querying runs:', error);
        showStatus('Error finding runs in area');
      }
    }

    async function queryUnifiedRunsInPolygon(polygonCoords) {
      const runs = [];
      
      // Query PMTiles runs (server-synced runs)
      try {
        const pmtilesRuns = await window.spatialIndex.queryPMTilesInPolygon(polygonCoords);
        runs.push(...pmtilesRuns);
      } catch (error) {
        console.warn('[HEATMAP-DEBUG] PMTiles query failed:', error);
      }
      
      // Query local runs (uploaded but not yet synced)
      try {
        const localRuns = window.spatialIndex.getRunsInPolygon(polygonCoords);
        runs.push(...localRuns);
      } catch (error) {
        console.warn('[HEATMAP-DEBUG] Local runs query failed:', error);
      }
      
      // Remove duplicates based on ID (in case run exists in both sources)
      const uniqueRuns = [];
      const seenIds = new Set();
      runs.forEach(run => {
        if (!seenIds.has(run.id)) {
          seenIds.add(run.id);
          uniqueRuns.push(run);
        }
      });
      
      return uniqueRuns;
    }

    function displayRunsInPanel(runs) {
      const panelContent = document.getElementById('panel-content');
      const panelSummary = document.getElementById('panel-summary');
      
      panelContent.innerHTML = '';
      
      if (runs.length === 0) {
        panelContent.innerHTML = '<p style="text-align: center; color: #666; margin: 20px; font-size: 16px;">No runs found in selected area</p>';
        panelSummary.innerHTML = '';
        return;
      }

      // Sort runs by date
      runs.sort((a, b) => new Date(b.metadata.start_time) - new Date(a.metadata.start_time));

      // Create run cards
      runs.forEach(run => {
        const card = document.createElement('div');
        card.className = 'run-card selected';
        card.dataset.runId = run.id;
        
        const startDate = new Date(run.metadata.start_time);
        const distance = (run.metadata.distance * 0.000621371).toFixed(2);
        const duration = formatDuration(run.metadata.duration);
        const type = run.metadata.activity_type || 'other';
        let icon = '❓';
        if (type === 'run') icon = '🏃';
        else if (type === 'bike' || type === 'biking') icon = '🚴';
        else if (type === 'walk') icon = '🚶';
        else if (type === 'hike') icon = '🥾';
        
        card.innerHTML = `
          <div style="display: flex; align-items: center;">
            <input type="checkbox" class="run-checkbox" checked>
            <div style="flex: 1;">
              <div class="run-date">${startDate.toLocaleDateString()} ${startDate.toLocaleTimeString()}</div>
              <div class="run-stats">
                <span>📏 ${distance} mi</span>
                <span>⏱️ ${duration}</span>
              </div>
            </div>
            <div style="font-size:20px;margin-left:4px;">${icon}</div>
          </div>
        `;

        selectedRuns.add(String(run.id));
        
        const checkbox = card.querySelector('.run-checkbox');
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedRuns.add(String(run.id));
            card.classList.add('selected');
          } else {
            selectedRuns.delete(String(run.id));
            card.classList.remove('selected');
          }
          updateMapDisplay();
        });

        panelContent.appendChild(card);
      });

      // Update summary
      const mostRecentRun = runs[0];
      const mostRecentDate = new Date(mostRecentRun.metadata.start_time);
      panelSummary.innerHTML = `
        <strong>${runs.length}</strong> runs found<br>
        <strong>Last run:</strong> ${mostRecentDate.toLocaleDateString()}
      `;

      updateMapDisplay();
    }

    function formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      } else {
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }
    }

    async function fetchLastActivity() {
      try {
        const container = document.getElementById('extras-content');
        container.innerHTML = '';
        
        let allRuns = [];
        
        // Get PMTiles runs (pre-packaged data) - query with large bbox to get all runs
        try {
          const worldBbox = [-180, -90, 180, 90]; // World coordinates
          const pmtilesRuns = await window.spatialIndex.queryPMTilesInPolygon([
            [-180, -90], [180, -90], [180, 90], [-180, 90], [-180, -90]
          ]);
          allRuns.push(...pmtilesRuns);
        } catch (error) {
          console.warn('Failed to query PMTiles runs:', error);
        }
        
        // Get user uploaded runs
        if (window.spatialIndex && window.spatialIndex.userRuns) {
          allRuns.push(...window.spatialIndex.userRuns);
        }
        
        if (allRuns.length === 0) {
          container.textContent = 'No activities';
          return;
        }
        
        // Find the most recent run by start_time from all sources
        let latestRun = null;
        let latestTime = null;
        
        for (const run of allRuns) {
          if (run.metadata && run.metadata.start_time) {
            const startTime = new Date(run.metadata.start_time);
            if (!latestTime || startTime > latestTime) {
              latestTime = startTime;
              latestRun = run;
            }
          }
        }
        
        if (!latestRun) {
          container.textContent = 'No activities';
          return;
        }
        
        console.log('[HEATMAP-DEBUG] Latest activity found - ID:', latestRun.id, 'Date:', latestRun.metadata.start_time, 'Source:', latestRun.metadata.source_file || 'PMTiles');
        
        const card = document.createElement('div');
        card.className = 'run-card';
        card.dataset.runId = latestRun.id;
        const startDate = new Date(latestRun.metadata.start_time);
        const distance = (latestRun.metadata.distance * 0.000621371).toFixed(2);
        const duration = formatDuration(latestRun.metadata.duration);
        const type = latestRun.metadata.activity_type || 'other';
        let icon = '❓';
        if (type === 'run') icon = '🏃';
        else if (type === 'bike' || type === 'biking') icon = '🚴';
        else if (type === 'walk') icon = '🚶';
        else if (type === 'hike') icon = '🥾';
        card.innerHTML = `
          <div class="run-date">${startDate.toLocaleDateString()} ${startDate.toLocaleTimeString()}</div>
          <div class="run-stats"><span>📏 ${distance} mi</span><span>⏱️ ${duration}</span></div>
          <div style="font-size:20px;margin-top:4px;">${icon}</div>
          <div style="margin-top:8px;">
            <label style="display:flex;align-items:center;font-size:12px;cursor:pointer;">
              <input type="checkbox" class="last-activity-checkbox" style="margin-right:6px;">
              Show only this activity
            </label>
          </div>`;
        
        // Add checkbox event listener
        const checkbox = card.querySelector('.last-activity-checkbox');
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            // Show only this run
            console.log('[HEATMAP-DEBUG] Filtering to show only run with ID:', latestRun.id);
            selectedRuns.clear();
            selectedRuns.add(String(latestRun.id));
            sidebarOpen = true; // Enable filtering
          } else {
            // Show all runs
            console.log('[HEATMAP-DEBUG] Clearing filters to show all runs');
            selectedRuns.clear();
            sidebarOpen = false; // Disable filtering
          }
          updateMapDisplay();
        });
        
        container.appendChild(card);
        
        // Add clear user uploads card
        if (window.spatialIndex && window.spatialIndex.userRuns && window.spatialIndex.userRuns.length > 0) {
          const clearCard = document.createElement('div');
          clearCard.className = 'run-card';
          clearCard.style.marginTop = '16px';
          clearCard.style.borderColor = '#dc3545';
          clearCard.innerHTML = `
            <div style="text-align:center;padding:8px;">
              <div style="font-weight:bold;margin-bottom:8px;">User Uploads</div>
              <div style="font-size:12px;color:#666;margin-bottom:12px;">${window.spatialIndex.userRuns.length} uploaded activities</div>
              <button id="clear-uploads-btn" style="
                background:#dc3545;
                color:white;
                border:none;
                padding:8px 16px;
                border-radius:4px;
                cursor:pointer;
                font-size:14px;
                width:100%;
              ">Clear All Uploads</button>
            </div>`;
          
          const clearBtn = clearCard.querySelector('#clear-uploads-btn');
          clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all uploaded activities? This cannot be undone.')) {
              clearUserUploads();
            }
          });
          
          container.appendChild(clearCard);
        }
        
        // Add current location card
        const locationCard = document.createElement('div');
        locationCard.className = 'run-card';
        locationCard.style.marginTop = '16px';
        locationCard.style.borderColor = '#007bff';
        locationCard.innerHTML = `
          <div style="text-align:center;padding:8px;">
            <div style="font-weight:bold;margin-bottom:8px;">📍 Current Location</div>
            <div style="font-size:12px;color:#666;margin-bottom:12px;">Zoom to your current position</div>
            <button id="location-btn" style="
              background:#007bff;
              color:white;
              border:none;
              padding:8px 16px;
              border-radius:4px;
              cursor:pointer;
              font-size:14px;
              width:100%;
            ">Find My Location</button>
          </div>`;
        
        const locationBtn = locationCard.querySelector('#location-btn');
        locationBtn.addEventListener('click', () => {
          zoomToCurrentLocation();
        });
        
        container.appendChild(locationCard);
        
      } catch (e) {
        console.error('Failed to fetch last activity', e);
      }
    }
    
    function clearUserUploads() {
      try {
        // Clear localStorage
        localStorage.removeItem('userRuns');
        
        // Clear spatialIndex
        if (window.spatialIndex) {
          window.spatialIndex.userRuns = [];
          window.spatialIndex.spatialIndex = window.spatialIndex.spatialIndex.filter(item => 
            !window.spatialIndex.userRuns.some(run => run.id === item.id)
          );
          window.spatialIndex.nextId = 1;
        }
        
        // Clear any filtering
        selectedRuns.clear();
        sidebarOpen = false;
        
        // Update map display
        updateMapDisplay();
        
        // Close and reopen extras panel to refresh
        const panel = document.getElementById('extras-panel');
        panel.classList.remove('open');
        setTimeout(() => {
          panel.classList.add('open');
          fetchLastActivity();
        }, 100);
        
        console.log('[HEATMAP-DEBUG] Cleared all user uploads');
        
      } catch (e) {
        console.error('Failed to clear user uploads', e);
      }
    }
    
    async function zoomToCurrentLocation() {
      const locationBtn = document.getElementById('location-btn');
      
      // Update button to show loading state
      const originalText = locationBtn.textContent;
      locationBtn.textContent = 'Getting location...';
      locationBtn.disabled = true;
      
      try {
        // Import Capacitor Geolocation
        const { Geolocation } = Capacitor;
        
        // Request permissions first
        const permissions = await Geolocation.requestPermissions();
        console.log('[HEATMAP-DEBUG] Location permissions:', permissions);
        
        if (permissions.location !== 'granted') {
          throw new Error('Location permission denied');
        }
        
        // Get current position using Capacitor API
        const position = await Geolocation.getCurrentPosition({
          enableHighAccuracy: true,
          timeout: 10000
        });
        
        const { latitude, longitude } = position.coords;
        console.log('[HEATMAP-DEBUG] Current location:', latitude, longitude);
        
        // Remove existing location marker if it exists
        if (map.getSource('current-location')) {
          if (map.getLayer('current-location-marker')) {
            map.removeLayer('current-location-marker');
          }
          map.removeSource('current-location');
        }
        
        // Add current location marker
        map.addSource('current-location', {
          type: 'geojson',
          data: {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [longitude, latitude]
            }
          }
        });
        
        map.addLayer({
          id: 'current-location-marker',
          type: 'circle',
          source: 'current-location',
          paint: {
            'circle-radius': 8,
            'circle-color': '#007bff',
            'circle-stroke-width': 3,
            'circle-stroke-color': '#ffffff'
          }
        });
        
        // Zoom to location
        map.flyTo({
          center: [longitude, latitude],
          zoom: 15,
          duration: 2000
        });
        
        // Restore button
        locationBtn.textContent = originalText;
        locationBtn.disabled = false;
        
      } catch (error) {
        console.error('[HEATMAP-DEBUG] Geolocation error:', error);
        
        let errorMessage = 'Unable to get your location';
        if (error.message.includes('denied') || error.message.includes('permission')) {
          errorMessage = 'Location access denied. Please enable location permissions in your device settings.';
        } else if (error.message.includes('unavailable')) {
          errorMessage = 'Location information unavailable. Make sure GPS is enabled.';
        } else if (error.message.includes('timeout')) {
          errorMessage = 'Location request timed out. Please try again.';
        }
        
        alert(errorMessage);
        
        // Restore button
        locationBtn.textContent = originalText;
        locationBtn.disabled = false;
      }
    }

      function updateMapDisplay() {
        // Rebuild the unified runs layer to include both PMTiles and local runs
        updateUnifiedRunsLayer();
      }

      async function updateUnifiedRunsLayer() {
        const zoom = map.getZoom();
        let allRunFeatures = [];
        
        // Get runs from local storage and add to display
        if (window.spatialIndex && window.spatialIndex.userRuns) {
          window.spatialIndex.userRuns.forEach(run => {
            if (!run.geoms) return;
            
            // Choose appropriate zoom level geometry
            const zoomLevel = window.spatialIndex.getZoomLevel(zoom);
            let geom = run.geoms[zoomLevel];
            
            // Fallback to other zoom levels if current one is invalid
            if (!geom || !geom.coordinates || geom.coordinates.length === 0) {
              geom = run.geoms['mid'] || run.geoms['low'] || run.geoms['high'] || run.geoms['full'];
            }
            
            if (geom && geom.coordinates && geom.coordinates.length > 1) {
              // Apply sidebar filtering if active
              if (sidebarOpen && selectedRuns.size > 0 && !selectedRuns.has(String(run.id))) {
                console.log('[HEATMAP-DEBUG] Filtering out user run ID:', run.id, 'SelectedRuns:', Array.from(selectedRuns));
                return; // Skip this run if it's not selected
              }
              
              if (sidebarOpen && selectedRuns.size > 0) {
                console.log('[HEATMAP-DEBUG] Including user run ID:', run.id, 'in filtered display');
              }
              
              allRunFeatures.push({
                type: 'Feature',
                geometry: geom,
                properties: {
                  id: Number(run.id),
                  start_time: run.metadata.start_time,
                  distance: run.metadata.distance,
                  duration: run.metadata.duration,
                  activity_type: run.metadata.activity_type,
                  activity_raw: run.metadata.activity_raw,
                  source_file: run.metadata.source_file
                }
              });
            }
          });
        }
        
        // Create GeoJSON for local runs
        const localRunsGeojson = {
          type: 'FeatureCollection',
          features: allRunFeatures
        };
        
        // Update local runs overlay (only shows uploaded runs, PMTiles shows server runs)
        if (map.getSource('localRunsOverlay')) {
          map.getSource('localRunsOverlay').setData(localRunsGeojson);
        } else {
          map.addSource('localRunsOverlay', {
            type: 'geojson',
            data: localRunsGeojson
          });
          
          // Add local runs layer with same styling as PMTiles
          map.addLayer({
            id: 'localRunsOverlay',
            type: 'line',
            source: 'localRunsOverlay',
            paint: {
              'line-color': 'rgba(255,0,0,0.5)', // Same red color as PMTiles
              'line-width': ['interpolate', ['linear'], ['zoom'], 0, 1, 14, 3]
            },
            maxzoom: 24
          });
        }
        
        // Apply filtering to PMTiles layer
        if (map.getLayer('runsVec')) {
          let filter = null;
          if (sidebarOpen && selectedRuns.size > 0) {
            const ids = Array.from(selectedRuns, id => Number(id));
            filter = ['in', ['get', 'id'], ['literal', ids]];
            console.log('[HEATMAP-DEBUG] Applying PMTiles filter for IDs:', ids);
          } else {
            console.log('[HEATMAP-DEBUG] Clearing PMTiles filter - showing all PMTiles runs');
          }
          map.setFilter('runsVec', filter);
        }
      }

    function exitDrawingMode() {
      isDrawingMode = false;
      isDrawing = false;
      document.getElementById('lasso-btn').classList.remove('active');
      document.getElementById('drawing-overlay').classList.remove('active');
    }

    function clearSelection() {
      clearPolygonDisplay();
      currentPolygon = null;
      polygonCoords = [];
      document.getElementById('clear-selection-btn').style.display = 'none';
      document.getElementById('side-panel').classList.remove('open');
      sidebarOpen = false;
      selectedRuns.clear();
      updateMapDisplay();
    }

    function normalizeActivityType(raw) {
      if (!raw) return 'other';
      const t = raw.toLowerCase();
      if (t.includes('run') || t.includes('jog')) return 'run';
      if (t.includes('bike') || t.includes('ride') || t.includes('cycl')) return 'bike';
      if (t.includes('walk')) return 'walk';
      if (t.includes('hike')) return 'hike';
      return 'other';
    }

    function haversine(a, b) {
      const R = 6371000;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(b[1] - a[1]);
      const dLon = toRad(b[0] - a[0]);
      const lat1 = toRad(a[1]);
      const lat2 = toRad(b[1]);
      const s = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s));
    }

    function computeDistance(coords) {
      let d = 0;
      for (let i = 1; i < coords.length; i++) {
        d += haversine(coords[i - 1], coords[i]);
      }
      return d;
    }

    function simplifyCoords(coords, tolerance) {
      if (coords.length <= 2) return coords;
      const simplified = [coords[0]];
      let last = coords[0];
      for (let i = 1; i < coords.length - 1; i++) {
        const c = coords[i];
        const dx = c[0] - last[0];
        const dy = c[1] - last[1];
        if (Math.sqrt(dx * dx + dy * dy) > tolerance) {
          simplified.push(c);
          last = c;
        }
      }
      simplified.push(coords[coords.length - 1]);
      return simplified;
    }

    function parseGpxText(text) {
      const doc = new DOMParser().parseFromString(text, 'application/xml');
      const trkpts = Array.from(doc.getElementsByTagName('trkpt'));
      const coords = [];
      const times = [];
      trkpts.forEach(pt => {
        const lat = parseFloat(pt.getAttribute('lat'));
        const lon = parseFloat(pt.getAttribute('lon'));
        coords.push([lon, lat]);
        const timeEl = pt.getElementsByTagName('time')[0];
        if (timeEl) times.push(new Date(timeEl.textContent));
      });
      const typeEl = doc.querySelector('trk > type');
      const rawType = typeEl ? typeEl.textContent.trim() : null;
      const meta = {
        start_time: times.length ? times[0].toISOString() : null,
        end_time: times.length ? times[times.length - 1].toISOString() : null,
        duration: times.length ? (times[times.length - 1] - times[0]) / 1000 : 0,
        distance: computeDistance(coords),
        activity_type: normalizeActivityType(rawType),
        activity_raw: rawType
      };
      return { coords, metadata: meta };
    }

      async function handleFileUpload(files) {
        const list = Array.from(files || []);

        showStatus('Processing and uploading runs...', 10000);

        try {
          let successCount = 0;
          for (const file of list) {
            console.log(`[HEATMAP-DEBUG] Processing file: ${file.name}`);
            const text = await file.text();
            const { coords, metadata } = parseGpxText(text);
            
            if (!coords || coords.length === 0) {
              console.warn(`[HEATMAP-DEBUG] No coordinates found in ${file.name}`);
              continue;
            }
            
            metadata.source_file = file.name;
            console.log(`[HEATMAP-DEBUG] Parsed ${coords.length} coordinates from ${file.name}`);

            await window.spatialIndex.addRun(coords, metadata);
            successCount++;
            console.log(`[HEATMAP-DEBUG] Successfully added run from ${file.name}`);
          }

          if (successCount > 0) {
            showStatus(`Successfully processed ${successCount} run(s). Check map for new routes.`, 4000);
            updateMapDisplay();
            
            // Pan to show the most recently added run if possible
            if (window.spatialIndex.userRuns.length > 0) {
              const lastRun = window.spatialIndex.userRuns[window.spatialIndex.userRuns.length - 1];
              if (lastRun.bbox) {
                const [minLng, minLat, maxLng, maxLat] = lastRun.bbox;
                map.fitBounds([[minLng, minLat], [maxLng, maxLat]], { padding: 50 });
              }
            }
          } else {
            showStatus('No valid runs found in uploaded files', 3000);
          }

        } catch (error) {
          console.error('[HEATMAP-DEBUG] Upload failed:', error);
          showStatus('Upload failed: ' + error.message, 5000);
        }
      }

    // Event listeners
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      setupDrawing();
      
      // Control buttons
      document.getElementById('zoom-in-btn').addEventListener('click', () => {
        map.zoomIn();
      });

      document.getElementById('zoom-out-btn').addEventListener('click', () => {
        map.zoomOut();
      });

      document.getElementById('reset-north-btn').addEventListener('click', () => {
        map.setBearing(0);
      });


      document.getElementById('lasso-btn').addEventListener('click', () => {
        if (!isDrawingMode) {
          isDrawingMode = true;
          document.getElementById('lasso-btn').classList.add('active');
          document.getElementById('drawing-overlay').classList.add('active');
          showStatus('Draw on map to select area');
        } else {
          exitDrawingMode();
        }
      });

      document.getElementById('clear-selection-btn').addEventListener('click', clearSelection);
      document.getElementById('panel-close').addEventListener('click', clearSelection);

      // Mobile panel collapse functionality
      document.getElementById('panel-collapse').addEventListener('click', () => {
        const panel = document.getElementById('side-panel');
        panel.classList.add('collapsed');
      });

      // Mobile panel expand functionality
      document.getElementById('expand-btn').addEventListener('click', () => {
        const panel = document.getElementById('side-panel');
        panel.classList.remove('collapsed');
      });

      // Panel controls
      document.getElementById('select-all').addEventListener('click', () => {
        const checkboxes = document.querySelectorAll('.run-checkbox');
        checkboxes.forEach(checkbox => {
          if (!checkbox.checked) {
            checkbox.checked = true;
            checkbox.dispatchEvent(new Event('change'));
          }
        });
      });

      document.getElementById('deselect-all').addEventListener('click', () => {
        const checkboxes = document.querySelectorAll('.run-checkbox');
        checkboxes.forEach(checkbox => {
          if (checkbox.checked) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change'));
          }
        });
      });

      document.getElementById('upload-btn').addEventListener('click', () => {
        document.getElementById('file-input').click();
      });

      document.getElementById('extras-btn').addEventListener('click', () => {
        const panel = document.getElementById('extras-panel');
        if (panel.classList.contains('open')) {
          panel.classList.remove('open');
        } else {
          panel.classList.add('open');
          fetchLastActivity();
        }
      });

      document.getElementById('extras-close').addEventListener('click', () => {
        document.getElementById('extras-panel').classList.remove('open');
        // Reset filtering to show all activities when closing the panel
        selectedRuns.clear();
        sidebarOpen = false;
        updateMapDisplay();
      });

      // Extras panel collapse functionality
      document.getElementById('extras-collapse').addEventListener('click', () => {
        const panel = document.getElementById('extras-panel');
        panel.classList.add('collapsed');
      });

      // Extras panel expand functionality
      document.getElementById('extras-expand-btn').addEventListener('click', () => {
        const panel = document.getElementById('extras-panel');
        panel.classList.remove('collapsed');
      });

      document.getElementById('file-input').addEventListener('change', (e) => {
        handleFileUpload(e.target.files);
        e.target.value = '';
      });
    });
  </script>
</body>
</html>

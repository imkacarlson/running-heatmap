<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Run Heatmap</title>
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body,
    html,
    #map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    /* progress bars */
    #progress-container {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 160px;
      display: none;
    }

    .progress {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #aaa;
      margin-top: 4px;
      position: relative;
    }

    .progress:first-child {
      margin-top: 0;
    }

    .progress-bar {
      background: #007bff;
      width: 0%;
      height: 100%;
      transition: width 0.2s ease;
    }

    /* Loading indicator */
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      display: none;
      z-index: 1000;
    }

    .spinner {
      border: 2px solid #f3f3f3;
      border-top: 2px solid #007bff;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 8px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Map control buttons */
    .map-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .control-btn {
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      color: #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: background-color 0.2s;
    }

    .control-btn:hover {
      background: #f5f5f5;
    }

    .control-btn:active {
      background: #e0e0e0;
    }

    .north-btn {
      font-size: 12px;
      font-weight: normal;
    }

    /* Side panel for run information */
    #side-panel {
      position: absolute;
      top: 0;
      right: -350px;
      width: 350px;
      height: 100%;
      background: white;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
      transition: right 0.3s ease;
      z-index: 1000;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #side-panel.open {
      right: 0;
    }

    .panel-header {
      padding: 15px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-close {
      cursor: pointer;
      font-size: 18px;
      color: #666;
    }

    .panel-close:hover {
      color: #333;
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }

    .run-card {
      border: 1px solid #dee2e6;
      border-radius: 4px;
      margin-bottom: 8px;
      padding: 10px;
      background: white;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .run-card:hover {
      background: #f8f9fa;
    }

    .run-card.selected {
      background: #e3f2fd;
      border-color: #2196f3;
    }

    .run-date {
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }

    .run-stats {
      font-size: 12px;
      color: #666;
      display: flex;
      gap: 15px;
    }

    .run-checkbox {
      margin-right: 8px;
    }

    .panel-summary {
      padding: 10px 15px;
      background: #f8f9fa;
      border-top: 1px solid #dee2e6;
      font-size: 14px;
    }

    .panel-controls {
      padding: 10px 15px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      gap: 10px;
    }

    .control-link {
      color: #007bff;
      cursor: pointer;
      text-decoration: underline;
      font-size: 12px;
    }

    .control-link:hover {
      color: #0056b3;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  
  <div class="map-controls">
    <div class="control-btn" id="zoom-in-btn" title="Zoom In">+</div>
    <div class="control-btn" id="zoom-out-btn" title="Zoom Out">−</div>
    <div class="control-btn north-btn" id="reset-north-btn" title="Reset North">N</div>
    <div class="control-btn" id="lasso-btn" title="Select Area">⊙</div>
    <div class="control-btn" id="clear-selection-btn" title="Clear Selection" style="display: none;">✕</div>
  </div>
  
  <div id="side-panel">
    <div class="panel-header">
      <span>Selected Area Runs</span>
      <span class="panel-close" id="panel-close">×</span>
    </div>
    <div class="panel-controls">
      <span class="control-link" id="select-all">Select All</span>
      <span class="control-link" id="deselect-all">Deselect All</span>
    </div>
    <div class="panel-content" id="panel-content">
      <!-- Run cards will be populated here -->
    </div>
    <div class="panel-summary" id="panel-summary">
      <!-- Summary info will be shown here -->
    </div>
  </div>

  <div id="progress-container"></div>
  <div id="loading-indicator">
    <div class="spinner"></div>
    Loading runs...
  </div>

  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {},
        layers: []
      },
      center: [-98, 39],
      zoom: 4
    });

    map.on('load', () => {
      map.addSource('osm-tiles', {
        type: 'raster',
        tiles: [
          'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
        ],
        tileSize: 256,
        attribution: '© OpenStreetMap contributors'
      });
      map.addLayer({
        id: 'osm-layer',
        type: 'raster',
        source: 'osm-tiles'
      });

      map.addSource('runs', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'runs-layer',
        type: 'line',
        source: 'runs',
        paint: {
          'line-color': 'rgba(255,0,0,0.4)',
          'line-width': [
            'interpolate', ['linear'], ['zoom'],
            0, 0.5,
            14, 2
          ]
        }
      });

      fetchAndUpdate();
    });

    const progressContainer = document.getElementById('progress-container');
    const loadingIndicator = document.getElementById('loading-indicator');

    function createProgress() {
      const wrapper = document.createElement('div');
      wrapper.className = 'progress';
      const bar = document.createElement('div');
      bar.className = 'progress-bar';
      wrapper.appendChild(bar);
      progressContainer.appendChild(wrapper);
      progressContainer.style.display = 'block';
      return { wrapper, bar };
    }

    function removeProgress(wrapper) {
      progressContainer.removeChild(wrapper);
      if (progressContainer.children.length === 0) {
        progressContainer.style.display = 'none';
      }
    }

    let activeRequest = null;
    let debounceTimeout = null;

    function fetchAndUpdate() {
      // Debounce rapid pan/zoom events
      if (debounceTimeout) {
        clearTimeout(debounceTimeout);
      }
      
      debounceTimeout = setTimeout(() => {
        performFetch();
      }, 150); // 150ms debounce delay
    }

    function performFetch() {
      if (activeRequest) {
        activeRequest.es.close();
        removeProgress(activeRequest.wrapper);
        activeRequest = null;
      }

      // Show loading indicator at start
      loadingIndicator.style.display = 'block';

      const b = map.getBounds();
      const z = Math.floor(map.getZoom());
      
      // Add run filtering if sidebar is open
      let url = `/api/stream_runs?minLat=${b.getSouth()}&minLng=${b.getWest()}&maxLat=${b.getNorth()}&maxLng=${b.getEast()}&zoom=${z}`;
      if (sidebarOpen) {
        if (selectedRuns.size > 0) {
          const runIds = Array.from(selectedRuns).join(',');
          url += `&filter_runs=${runIds}`;
        } else {
          // If sidebar is open but no runs selected, show nothing
          url += `&filter_runs=-1`;
        }
      }

      const { wrapper, bar } = createProgress();
      const es = new EventSource(url);
      activeRequest = { es, wrapper };

      const finalize = () => {
        removeProgress(wrapper);
        loadingIndicator.style.display = 'none';
        if (activeRequest && activeRequest.es === es) {
          activeRequest = null;
        }
        es.close();
      };

      let allFeatures = [];

      es.addEventListener('progress', (e) => {
        bar.style.width = e.data + '%';
        // Hide loading indicator once progress starts
        if (loadingIndicator.style.display !== 'none') {
          loadingIndicator.style.display = 'none';
        }
      });

      es.addEventListener('chunk', (e) => {
        const chunkData = JSON.parse(e.data);
        allFeatures = allFeatures.concat(chunkData.features);
        
        // Update map with accumulated features for progressive rendering
        map.getSource('runs').setData({
          type: 'FeatureCollection',
          features: allFeatures
        });
      });

      es.addEventListener('complete', (e) => {
        finalize();
      });

      es.addEventListener('data', (e) => {
        // Fallback for old single-response mode
        map.getSource('runs').setData(JSON.parse(e.data));
        finalize();
      });

      es.onerror = finalize;
    }

    map.on('moveend', fetchAndUpdate);

    // Map control button event listeners
    document.getElementById('zoom-in-btn').addEventListener('click', () => {
      map.zoomIn();
    });

    document.getElementById('zoom-out-btn').addEventListener('click', () => {
      map.zoomOut();
    });

    document.getElementById('reset-north-btn').addEventListener('click', () => {
      map.setBearing(0);
    });

    // Custom polygon drawing functionality
    let isDrawingMode = false;
    let selectedRuns = new Set();
    let isDrawing = false;
    let polygonCoords = [];
    let currentPolygon = null;
    let sidebarOpen = false;

    // Lasso selection functionality with click-and-drag
    document.getElementById('lasso-btn').addEventListener('click', () => {
      if (!isDrawingMode) {
        // Start drawing mode
        isDrawingMode = true;
        document.getElementById('lasso-btn').style.background = '#007bff';
        document.getElementById('lasso-btn').style.color = 'white';
        map.getCanvas().style.cursor = 'crosshair';
        
        // Add drawing event listeners
        map.on('mousedown', startDrawing);
        map.on('mousemove', continueDrawing);
        map.on('mouseup', finishDrawing);
      } else {
        // Exit drawing mode
        exitDrawingMode();
      }
    });

    function startDrawing(e) {
      if (!isDrawingMode) return;
      
      e.preventDefault();
      isDrawing = true;
      polygonCoords = [[e.lngLat.lng, e.lngLat.lat]];
      
      // Clear any existing polygon
      if (currentPolygon) {
        map.removeLayer('selection-polygon');
        map.removeSource('selection-polygon');
        currentPolygon = null;
      }
    }

    function continueDrawing(e) {
      if (!isDrawing || !isDrawingMode) return;
      
      polygonCoords.push([e.lngLat.lng, e.lngLat.lat]);
      
      // Update the polygon display
      updatePolygonDisplay();
    }

    function finishDrawing(e) {
      if (!isDrawing || !isDrawingMode) return;
      
      isDrawing = false;
      
      if (polygonCoords.length >= 3) {
        // Close the polygon
        polygonCoords.push(polygonCoords[0]);
        updatePolygonDisplay();
        
        // Query runs in the area
        queryRunsInArea(polygonCoords);
        
        // Show clear button
        document.getElementById('clear-selection-btn').style.display = 'block';
      }
      
      // Exit drawing mode
      exitDrawingMode();
    }

    function updatePolygonDisplay() {
      if (polygonCoords.length < 2) return;
      
      // Remove existing polygon if any
      if (map.getSource('selection-polygon')) {
        if (map.getLayer('selection-polygon-outline')) {
          map.removeLayer('selection-polygon-outline');
        }
        if (map.getLayer('selection-polygon')) {
          map.removeLayer('selection-polygon');
        }
        map.removeSource('selection-polygon');
      }
      
      let geometry;
      
      // While drawing, show as a line; when complete, show as polygon
      if (isDrawing) {
        geometry = {
          type: 'LineString',
          coordinates: polygonCoords
        };
      } else {
        geometry = {
          type: 'Polygon',
          coordinates: [polygonCoords]
        };
      }
      
      // Add geometry to map
      map.addSource('selection-polygon', {
        type: 'geojson',
        data: {
          type: 'Feature',
          geometry: geometry
        }
      });
      
      if (isDrawing) {
        // Show as line while drawing
        map.addLayer({
          id: 'selection-polygon-outline',
          type: 'line',
          source: 'selection-polygon',
          paint: {
            'line-color': '#007bff',
            'line-width': 3,
            'line-opacity': 0.8
          }
        });
      } else {
        // Show as filled polygon when complete
        map.addLayer({
          id: 'selection-polygon',
          type: 'fill',
          source: 'selection-polygon',
          paint: {
            'fill-color': '#007bff',
            'fill-opacity': 0.2
          }
        });
        
        map.addLayer({
          id: 'selection-polygon-outline',
          type: 'line',
          source: 'selection-polygon',
          paint: {
            'line-color': '#007bff',
            'line-width': 2,
            'line-dasharray': [5, 5]
          }
        });
      }
      
      if (!isDrawing) {
        currentPolygon = geometry;
      }
    }

    function exitDrawingMode() {
      isDrawingMode = false;
      isDrawing = false;
      document.getElementById('lasso-btn').style.background = 'white';
      document.getElementById('lasso-btn').style.color = '#333';
      map.getCanvas().style.cursor = '';
      
      // Remove event listeners
      map.off('mousedown', startDrawing);
      map.off('mousemove', continueDrawing);
      map.off('mouseup', finishDrawing);
    }

    // Clear selection functionality
    document.getElementById('clear-selection-btn').addEventListener('click', () => {
      clearSelection();
    });

    function clearSelection() {
      // Remove polygon from map
      if (map.getSource('selection-polygon')) {
        if (map.getLayer('selection-polygon-outline')) {
          map.removeLayer('selection-polygon-outline');
        }
        if (map.getLayer('selection-polygon')) {
          map.removeLayer('selection-polygon');
        }
        map.removeSource('selection-polygon');
      }
      
      // Clear polygon data
      currentPolygon = null;
      polygonCoords = [];
      
      // Hide clear button
      document.getElementById('clear-selection-btn').style.display = 'none';
      
      // Close side panel
      document.getElementById('side-panel').classList.remove('open');
      sidebarOpen = false;
      
      // Clear selection and show all runs
      selectedRuns.clear();
      updateMapDisplay();
    }

    // Select All / Deselect All functionality
    document.getElementById('select-all').addEventListener('click', () => {
      const checkboxes = document.querySelectorAll('.run-checkbox');
      checkboxes.forEach(checkbox => {
        if (!checkbox.checked) {
          checkbox.checked = true;
          checkbox.dispatchEvent(new Event('change'));
        }
      });
    });

    document.getElementById('deselect-all').addEventListener('click', () => {
      const checkboxes = document.querySelectorAll('.run-checkbox');
      checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
          checkbox.checked = false;
          checkbox.dispatchEvent(new Event('change'));
        }
      });
    });

    // Side panel functionality
    document.getElementById('panel-close').addEventListener('click', () => {
      clearSelection();
    });

    // Query runs in selected area
    async function queryRunsInArea(coordinates) {
      try {
        const response = await fetch('/api/runs_in_area', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            polygon: coordinates
          })
        });

        if (response.ok) {
          const data = await response.json();
          displayRunsInPanel(data.runs);
          document.getElementById('side-panel').classList.add('open');
          sidebarOpen = true;
        } else {
          console.error('Failed to query runs in area');
        }
      } catch (error) {
        console.error('Error querying runs:', error);
      }
    }

    // Display runs in side panel
    function displayRunsInPanel(runs) {
      const panelContent = document.getElementById('panel-content');
      const panelSummary = document.getElementById('panel-summary');
      
      panelContent.innerHTML = '';
      
      if (runs.length === 0) {
        panelContent.innerHTML = '<p style="text-align: center; color: #666; margin: 20px;">No runs found in selected area</p>';
        panelSummary.innerHTML = '';
        return;
      }

      // Sort runs by date (newest first)
      runs.sort((a, b) => new Date(b.metadata.start_time) - new Date(a.metadata.start_time));

      // Create run cards
      runs.forEach(run => {
        const card = document.createElement('div');
        card.className = 'run-card';
        card.dataset.runId = run.id;
        
        const startDate = new Date(run.metadata.start_time);
        const distance = (run.metadata.distance * 0.000621371).toFixed(2); // Convert to miles
        const duration = formatDuration(run.metadata.duration);
        
        card.innerHTML = `
          <div style="display: flex; align-items: center;">
            <input type="checkbox" class="run-checkbox" checked>
            <div style="flex: 1;">
              <div class="run-date">${startDate.toLocaleDateString()} ${startDate.toLocaleTimeString()}</div>
              <div class="run-stats">
                <span>📏 ${distance} mi</span>
                <span>⏱️ ${duration}</span>
              </div>
            </div>
          </div>
        `;

        // Add to selected runs by default
        selectedRuns.add(run.id);
        
        // Handle checkbox changes
        const checkbox = card.querySelector('.run-checkbox');
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedRuns.add(run.id);
            card.classList.add('selected');
          } else {
            selectedRuns.delete(run.id);
            card.classList.remove('selected');
          }
          // Immediately update map when checkbox changes
          updateMapDisplay();
        });

        card.classList.add('selected');
        panelContent.appendChild(card);
      });

      // Update summary
      const mostRecentRun = runs[0];
      const mostRecentDate = new Date(mostRecentRun.metadata.start_time);
      panelSummary.innerHTML = `
        <strong>${runs.length}</strong> runs found<br>
        <strong>Last run:</strong> ${mostRecentDate.toLocaleDateString()}
      `;

      updateMapDisplay();
    }

    // Format duration in seconds to readable format
    function formatDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      } else {
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }
    }

    // Update map display to show only selected runs
    function updateMapDisplay() {
      console.log('Selected runs:', Array.from(selectedRuns), 'Sidebar open:', sidebarOpen);
      
      // If sidebar is open and no runs selected, immediately clear the map
      if (sidebarOpen && selectedRuns.size === 0) {
        map.getSource('runs').setData({
          type: 'FeatureCollection',
          features: []
        });
      }
      
      // Trigger a refresh of the map data with current selection
      fetchAndUpdate();
    }
  </script>
</body>

</html>

<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Run Heatmap</title>
  <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body,
    html,
    #map {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    /* progress bars */
    #progress-container {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 160px;
      display: none;
    }

    .progress {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #aaa;
      margin-top: 4px;
      position: relative;
    }

    .progress:first-child {
      margin-top: 0;
    }

    .progress-bar {
      background: #007bff;
      width: 0%;
      height: 100%;
      transition: width 0.2s ease;
    }

    /* Loading indicator */
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      display: none;
      z-index: 1000;
    }

    /* Rendering status indicator */
    #render-status {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      display: none;
      z-index: 1000;
    }

    .render-active {
      background: rgba(255, 165, 0, 0.8) !important;
      color: black !important;
    }

    .spinner {
      border: 2px solid #f3f3f3;
      border-top: 2px solid #007bff;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 8px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="progress-container"></div>
  <div id="loading-indicator">
    <div class="spinner"></div>
    Loading runs...
  </div>
  <div id="render-status">Rendering...</div>

  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {},
        layers: []
      },
      center: [-98, 39],
      zoom: 4
    });

    map.on('load', () => {
      map.addSource('osm-tiles', {
        type: 'raster',
        tiles: [
          'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
        ],
        tileSize: 256,
        attribution: 'Â© OpenStreetMap contributors'
      });
      map.addLayer({
        id: 'osm-layer',
        type: 'raster',
        source: 'osm-tiles'
      });

      map.addSource('runs', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'runs-layer',
        type: 'line',
        source: 'runs',
        paint: {
          'line-color': 'rgba(255,0,0,0.4)',
          'line-width': [
            'interpolate', ['linear'], ['zoom'],
            0, 0.5,
            14, 2
          ]
        }
      });

      fetchAndUpdate();
    });

    const progressContainer = document.getElementById('progress-container');
    const loadingIndicator = document.getElementById('loading-indicator');
    const renderStatus = document.getElementById('render-status');

    function createProgress() {
      const wrapper = document.createElement('div');
      wrapper.className = 'progress';
      const bar = document.createElement('div');
      bar.className = 'progress-bar';
      wrapper.appendChild(bar);
      progressContainer.appendChild(wrapper);
      progressContainer.style.display = 'block';
      return { wrapper, bar };
    }

    function removeProgress(wrapper) {
      progressContainer.removeChild(wrapper);
      if (progressContainer.children.length === 0) {
        progressContainer.style.display = 'none';
      }
    }

    let activeRequest = null;
    let debounceTimeout = null;
    let preloadCache = new Map(); // Cache for preloaded data
    let activePreloads = new Set(); // Track active preload requests
    let renderTimeout = null;
    let isRendering = false;

    function fetchAndUpdate() {
      // Debounce rapid pan/zoom events
      if (debounceTimeout) {
        clearTimeout(debounceTimeout);
      }
      
      debounceTimeout = setTimeout(() => {
        performFetch();
      }, 150); // 150ms debounce delay
    }

    function performFetch() {
      if (activeRequest) {
        activeRequest.es.close();
        removeProgress(activeRequest.wrapper);
        activeRequest = null;
      }

      const b = map.getBounds();
      const z = Math.floor(map.getZoom());
      
      // Add buffer to bounds to ensure lines extending beyond viewport are included
      const latBuffer = (b.getNorth() - b.getSouth()) * 0.1; // 10% buffer
      const lngBuffer = (b.getEast() - b.getWest()) * 0.1;   // 10% buffer
      
      const minLat = b.getSouth() - latBuffer;
      const maxLat = b.getNorth() + latBuffer;
      const minLng = b.getWest() - lngBuffer;
      const maxLng = b.getEast() + lngBuffer;
      
      // Check cache first for instant loading at street level
      const cachedData = checkCacheForCurrentView(minLat, minLng, maxLat, maxLng, z);
      if (cachedData) {
        console.log('ðŸš€ Using cached data for instant loading');
        showRenderingStatus();
        map.getSource('runs').setData(cachedData);
        trackRenderingComplete();
        return;
      }

      // Show loading indicator at start
      loadingIndicator.style.display = 'block';
      
      const url = `/api/stream_runs?minLat=${minLat}&minLng=${minLng}&maxLat=${maxLat}&maxLng=${maxLng}&zoom=${z}`;

      const { wrapper, bar } = createProgress();
      const es = new EventSource(url);
      activeRequest = { es, wrapper };

      const finalize = () => {
        removeProgress(wrapper);
        loadingIndicator.style.display = 'none';
        if (activeRequest && activeRequest.es === es) {
          activeRequest = null;
        }
        es.close();
        
        // Ensure rendering tracking is triggered for final completion
        trackRenderingComplete();
      };

      let allFeatures = [];

      es.addEventListener('progress', (e) => {
        bar.style.width = e.data + '%';
        // Hide loading indicator once progress starts
        if (loadingIndicator.style.display !== 'none') {
          loadingIndicator.style.display = 'none';
        }
      });

      es.addEventListener('chunk', (e) => {
        const chunkData = JSON.parse(e.data);
        allFeatures = allFeatures.concat(chunkData.features);
        
        // Show rendering status when first chunk arrives
        if (allFeatures.length === chunkData.features.length) {
          showRenderingStatus();
        }
        
        // Update map with accumulated features for progressive rendering
        map.getSource('runs').setData({
          type: 'FeatureCollection',
          features: allFeatures
        });
        
        trackRenderingComplete();
      });

      es.addEventListener('complete', (e) => {
        // Cache the final accumulated data for future instant loading
        if (allFeatures.length > 0) {
          const cacheKey = `${minLat.toFixed(4)},${minLng.toFixed(4)},${maxLat.toFixed(4)},${maxLng.toFixed(4)}_${z}`;
          const finalData = { type: 'FeatureCollection', features: allFeatures };
          preloadCache.set(cacheKey, finalData);
        }
        finalize();
      });

      es.addEventListener('data', (e) => {
        // Fallback for old single-response mode
        const data = JSON.parse(e.data);
        showRenderingStatus();
        map.getSource('runs').setData(data);
        trackRenderingComplete();
        
        // Cache this data too
        const cacheKey = `${minLat.toFixed(4)},${minLng.toFixed(4)},${maxLat.toFixed(4)},${maxLng.toFixed(4)}_${z}`;
        preloadCache.set(cacheKey, data);
        
        finalize();
      });

      es.onerror = finalize;
    }

    // Rendering progress tracking functions
    function showRenderingStatus() {
      if (!isRendering) {
        isRendering = true;
        renderStatus.style.display = 'block';
        renderStatus.className = 'render-active';
        renderStatus.textContent = 'Rendering lines...';
        
        // Clear any existing timeout
        if (renderTimeout) {
          clearTimeout(renderTimeout);
        }
      }
    }

    function trackRenderingComplete() {
      // Use RAF to detect when browser has finished rendering
      if (renderTimeout) {
        clearTimeout(renderTimeout);
      }
      
      // Multiple approaches to detect rendering completion
      renderTimeout = setTimeout(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // Wait for 2 RAF cycles to ensure rendering is done
            setTimeout(() => {
              if (isRendering) {
                isRendering = false;
                renderStatus.className = '';
                renderStatus.textContent = 'Rendering complete';
                
                // Hide status after 2 seconds
                setTimeout(() => {
                  renderStatus.style.display = 'none';
                }, 2000);
              }
            }, 50); // Small delay to catch heavy rendering
          });
        });
      }, 100); // Initial delay to batch rapid updates
    }

    // Preloading system for street-level optimization
    function generateAdjacentBounds(centerBounds, bufferFactor = 0.1) {
      const latSpan = centerBounds.getNorth() - centerBounds.getSouth();
      const lngSpan = centerBounds.getEast() - centerBounds.getWest();
      
      const latStep = latSpan * (1 + bufferFactor * 2);
      const lngStep = lngSpan * (1 + bufferFactor * 2);
      
      const adjacent = [];
      
      // Generate 3x3 grid around current view (excluding center)
      for (let latOffset = -1; latOffset <= 1; latOffset++) {
        for (let lngOffset = -1; lngOffset <= 1; lngOffset++) {
          if (latOffset === 0 && lngOffset === 0) continue; // Skip center (current view)
          
          const south = centerBounds.getSouth() + (latOffset * latStep);
          const north = centerBounds.getNorth() + (latOffset * latStep);
          const west = centerBounds.getWest() + (lngOffset * lngStep);
          const east = centerBounds.getEast() + (lngOffset * lngStep);
          
          adjacent.push({
            minLat: south, maxLat: north,
            minLng: west, maxLng: east,
            key: `${south.toFixed(4)},${west.toFixed(4)},${north.toFixed(4)},${east.toFixed(4)}`
          });
        }
      }
      
      return adjacent;
    }

    function preloadAdjacentAreas() {
      const zoom = Math.floor(map.getZoom());
      
      // Only preload at street level (zoom 14+) where users pan locally
      if (zoom < 14) return;
      
      const bounds = map.getBounds();
      const adjacentAreas = generateAdjacentBounds(bounds);
      
      adjacentAreas.forEach(area => {
        const cacheKey = `${area.key}_${zoom}`;
        
        // Skip if already cached or currently loading
        if (preloadCache.has(cacheKey) || activePreloads.has(cacheKey)) return;
        
        activePreloads.add(cacheKey);
        
        // Make background request
        fetch(`/api/runs?minLat=${area.minLat}&minLng=${area.minLng}&maxLat=${area.maxLat}&maxLng=${area.maxLng}&zoom=${zoom}`)
          .then(r => r.json())
          .then(data => {
            preloadCache.set(cacheKey, data);
            
            // Clean up old cache entries (keep last 20)
            if (preloadCache.size > 20) {
              const keys = Array.from(preloadCache.keys());
              keys.slice(0, preloadCache.size - 20).forEach(key => preloadCache.delete(key));
            }
          })
          .catch(err => console.log('Preload failed:', err))
          .finally(() => {
            activePreloads.delete(cacheKey);
          });
      });
    }

    function checkCacheForCurrentView(minLat, minLng, maxLat, maxLng, zoom) {
      const key = `${minLat.toFixed(4)},${minLng.toFixed(4)},${maxLat.toFixed(4)},${maxLng.toFixed(4)}_${zoom}`;
      return preloadCache.get(key);
    }

    map.on('moveend', () => {
      fetchAndUpdate();
      
      // Start preloading adjacent areas after a short delay
      setTimeout(() => {
        preloadAdjacentAreas();
      }, 500);
    });
  </script>
</body>

</html>
